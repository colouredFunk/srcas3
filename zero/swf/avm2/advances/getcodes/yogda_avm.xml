<avm>
	<opcodes>
		<opcode type="UNU" hex="$00" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="IIU" hex="$01" string="breakpoint">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="IIU" hex="$02" string="nop">
			<short>Do nothing.</short>
			<params></params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>Do nothing.</description>
			<tamarincode>
				<![CDATA[
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$03" string="throw">
			<short>Throws an exception.</short>
			<params></params>
			<stack in_count="1" out_count="0"><![CDATA[ _ , value => _ ]]><sparam name="value" class="in"/></stack>
			<description>
				<![CDATA[
The top value of the stack is popped off the stack and then thrown. The thrown value can be
of any type.

When a throw is executed, the current method's exception handler table is searched for an
exception handler. An exception handler matches if its range of offsets includes the offset of
this instruction, and if its type matches the type of the thrown object, or is a base class of the
type thrown. The first handler that matches is the one used.If a handler is found then the stack is 
cleared, the exception object is pushed onto the stack,and then execution resumes at the 
instruction offset specified by the handler.If a handler is not found, then the method exits, 
and the exception is rethrown in the invoking method, at which point it is searched for an 
exception handler as described here.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				core->throwAtom(*sp--);
				// unreachable
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$04" string="getsuper">
			<short>Gets a property from a base class.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="3" out_count="1"><![CDATA[ _ , obj, [ns], [name] => _ , value]]><sparam name="obj" class="in"/><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime

Once the multiname is constructed, the base class of obj is determined and the multiname is
resolved in the declared traits of the base class. The value of the resolved property is pushed
onto the stack. See "Resolving multinames" on page 10.
]]>
			</description>
			<tamarincode>
				<![CDATA[
			a1 = 0;			// not a value - instruction is getsuper
			getsuper_setsuper_impl:
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				if (multiname->isRuntime())
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultiname(env, aux_memory->multiname2, sp);
					multiname = &aux_memory->multiname2;
				}
				a2 = *(sp--);	// object
				env->nullcheck(a2);
				if (a1 == 0)
					*(++sp) = env->getsuper(a2, multiname);
				else
					env->setsuper(a2, multiname, a1);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$05" string="setsuper">
			<short>Sets a property in a base class.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="4" out_count="0"><![CDATA[ _ , obj, [ns], [name], value => _ ]]><sparam name="obj" class="in"/><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="value" class="in"/></stack>
			<description>
				<![CDATA[
value is the value that the property will be set to. value is popped off the stack and saved.

index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime.

Once the multiname is constructed the base class of obj is determined and the multiname is
resolved in the declared traits of the base class. The property is then set to value. See
"Resolving multinames" on page 10.
]]>
			</description>
			<tamarincode>
				<![CDATA[
a1 = *(sp--);	// value
goto getsuper_setsuper_impl;

getsuper_setsuper_impl:
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				if (multiname->isRuntime())
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultiname(env, aux_memory->multiname2, sp);
					multiname = &aux_memory->multiname2;
				}
				a2 = *(sp--);	// object
				env->nullcheck(a2);
				if (a1 == 0)
					*(++sp) = env->getsuper(a2, multiname);
				else
					env->setsuper(a2, multiname, a1);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$06" string="dxns">
			<short>Sets the default XML namespace.</short>
			<params>
				<param name="index" type="u30" class="string"/>
			</params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the string constant pool. The string at index is used
as the uri for the default XML namespace for this method.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				AvmAssert(info->setsDxns());
				SAVE_EXPC;
				core->setDxns(&aux_memory->methodFrame, pool->getString((uint32_t)U30ARG));
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$07" string="dxnslate">
			<short>Sets the default XML namespace with a value determined at runtime.</short>
			<params></params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[
The top value on the stack is popped, converted to a string, and that string is used as the uri
for the default XML namespace for this method.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				AvmAssert(info->setsDxns());
				SAVE_EXPC;
				core->setDxnsLate(&aux_memory->methodFrame, *sp);
				sp--;
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$08" string="kill">
			<short>Kills a local register.</short>
			<params>
				<param name="index" type="u30" class="integer"/>
			</params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[					
index is a u30 that must be an index of a local register. The local register at index is killed. It
is killed by setting its value to undefined.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				u1 = U30ARG;
				framep[u1] = undefinedAtom;
				NEXT;
]]>
			</tamarincode>
		</opcode>

		<opcode type="III" hex="$09" string="label">
			<short> Compiler uses this opcode to indicate backwards label offets?.</short>

		<stack in_count="0" out_count="0"></stack>
		</opcode>


		<opcode type="UNU" hex="$0A" string="Unused"><stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$0B" string="Unused"><stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="IIC" hex="$0C" string="ifnlt">
			<short>Branch if the first value is not less than the second value.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="2" out_count="0"><![CDATA[ _ , value1, value2 => _ ]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump if value1 is not less than value2.
Compute value1 < value2 using the abstract relational comparison algorithm in ECMA-262
section 11.8.5. If the result of the comparison is false, then jump the number of bytes
indicated by offset. Otherwise continue executing code from this point.

Notes

This appears to have the same effect as ifge, however, their handling of NaN is different.
If either of the compared values is NaN then the comparison value1 < value2 will return
undefined. In that case ifnlt will branch (undefined is not true), but ifge will not branch.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				LOAD_OFFSET_AND_FETCH_SS(a1,a2,i1);
			PEEPHOLE_ONLY( compare_nlt_and_branch_impl: )
				IFNCMP_TWO_VALUES(<, core->compare(a1, a2) == trueAtom, a1, a2, i1);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$0D" string="ifnle">
			<short>Branch if the first value is not less than or equal to the second value.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="2" out_count="0"><![CDATA[ _ , value1, value2 => _ ]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump if value1 is not less than or equal to
value2.

Compute value2 < value1 using the abstract relational comparison algorithm in ECMA-262
section 11.8.5. If the result of the comparison is true, jump the number of bytes indicated
by offset. Otherwise continue executing code from this point.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				LOAD_OFFSET_AND_FETCH_SS(a1,a2,i1);
				PEEPHOLE_ONLY( compare_nle_and_branch_impl: )
				IFNCMP_TWO_VALUES(<=, core->compare(a2, a1) == falseAtom,a1,a2,i1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$0E" string="ifngt">
			<short>Branch if the first value is not greater than the second value.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="2" out_count="0"><![CDATA[ _ , value1, value2 => _ ]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump if value1 is not greater than or value2.

Compute value2 < value1 using the abstract relational comparison algorithm in ECMA-262
section 11.8.5. If the result of the comparison is not true, jump the number of bytes
indicated by offset. Otherwise continue executing code from this point
]]>
			</description>
			<tamarincode>
				<![CDATA[
				LOAD_OFFSET_AND_FETCH_SS(a1,a2,i1);
			PEEPHOLE_ONLY( compare_ngt_and_branch_impl: )
				IFNCMP_TWO_VALUES(>, core->compare(a2, a1) == trueAtom,a1,a2,i1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$0F" string="ifnge">
			<short>Branch if the first value is not greater than or equal to the second value.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="2" out_count="0"><![CDATA[ _ , value1, value2 => _ ]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump if value1 is not greater than or equal to
value2.
Compute value1 < value2 using the abstract relational comparison algorithm in ECMA-262
section 11.8.5. If the result of the comparison is not false, jump the number of bytes
indicated by offset. Otherwise continue executing code from this point.

Notes

This appears to have the same effect as iflt, however, their handling of NaN is different. If
either of the compared values is NaN then the comparison value1 < value2 will return
undefined. In that case ifnge will branch (undefined is not false), but iflt will not
branch.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				LOAD_OFFSET_AND_FETCH_SS(a1,a2,i1);
			PEEPHOLE_ONLY( compare_nge_and_branch_impl: )
				IFNCMP_TWO_VALUES(>=, core->compare(a1, a2) == falseAtom,a1,a2,i1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$10" string="jump">
			<short>Unconditional branch.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump. Jump the number of bytes indicated by
offset and resume execution there.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				i1 = S24ARG;
				if (i1 < 0) {
					SAVE_EXPC_S24;
				    core->branchCheck(env, interruptable, (int32_t)i1);
				}
				pc += i1;
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$11" string="iftrue">
			<short>Branch if true.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="1" out_count="0"><![CDATA[ _ , value => _ ]]><sparam name="value" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump.
Pop value off the stack and convert it to a Boolean. If the converted value is true, jump the
number of bytes indicated by offset. Otherwise continue executing code from this point.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a2 = trueAtom;
			branch_on_boolean:
				a1 = *(sp--);
				if (IS_BOOLEAN(a1))
					;
				else if (IS_INTEGER(a1))
					a1 = a1 == zeroIntAtom ? falseAtom : trueAtom;
				else
					a1 = AvmCore::booleanAtom(a1);  // does not throw or change the XML namespace
				i1 = S24ARG;
				if (a1 == a2)
				{
					if (i1 < 0) {
						SAVE_EXPC_S24;
						core->branchCheck(env, interruptable, (int32_t)i1);
					}
                    pc += i1;
				}
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$12" string="iffalse">
			<short>Branch if false.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="1" out_count="0"><![CDATA[ _ , value => _ ]]><sparam name="value" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump.
Pop value off the stack and convert it to a Boolean. If the converted value is false, jump the
number of bytes indicated by offset. Otherwise continue executing code from this point.
]]>
			</description>
			<tamarincode>
				<![CDATA[
			a2 = falseAtom;
			goto branch_on_boolean;
			
			branch_on_boolean:
				a1 = *(sp--);
				if (IS_BOOLEAN(a1))
					;
				else if (IS_INTEGER(a1))
					a1 = a1 == zeroIntAtom ? falseAtom : trueAtom;
				else
					a1 = AvmCore::booleanAtom(a1);  // does not throw or change the XML namespace
				i1 = S24ARG;
				if (a1 == a2)
				{
					if (i1 < 0) {
						SAVE_EXPC_S24;
						core->branchCheck(env, interruptable, (int32_t)i1);
					}
                    pc += i1;
				}
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$13" string="ifeq">
			<short>Branch if the first value is equal to the second value.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="2" out_count="0"><![CDATA[ _ , value1, value2 => _ ]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump if value1 is equal to value2.
Compute value1 == value2 using the abstract equality comparison algorithm in ECMA-262
section 11.9.3 and ECMA-347 section 11.5.1. If the result of the comparison is true, jump
the number of bytes indicated by offset. Otherwise continue executing code from this point.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				LOAD_OFFSET_AND_FETCH_SS(a1,a2,i1);
			PEEPHOLE_ONLY( compare_eq_and_branch_impl: )
				IFCMP_TWO_VALUES(==, core->equals(a1,a2) == trueAtom, a1, a2, i1);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$14" string="ifne">
			<short>Branch if the first value is not equal to the second value.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="2" out_count="0"><![CDATA[ _ , value1, value2 => _ ]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump if value1 is not equal to value2.
Compute value1 == value2 using the abstract equality comparison algorithm in ECMA-262
section 11.9.3 and ECMA-347 Section 11.5.1. If the result of the comparison is false,
jump the number of bytes indicated by offset. Otherwise continue executing code from this
point.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				LOAD_OFFSET_AND_FETCH_SS(a1,a2,i1);
			PEEPHOLE_ONLY( compare_ne_and_branch_impl: )
				IFNCMP_TWO_VALUES(==, core->equals(a1,a2) == trueAtom, a1, a2, i1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$15" string="iflt">
			<short>Branch if the first value is less than the second value.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="2" out_count="0"><![CDATA[ _ , value1, value2 => _ ]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump if value1 is less than value2.
Compute value1 < value2 using the abstract relational comparison algorithm in ECMA-262
section 11.8.5. If the result of the comparison is true, jump the number of bytes indicated
by offset. Otherwise continue executing code from this point.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				LOAD_OFFSET_AND_FETCH_SS(a1,a2,i1);
			PEEPHOLE_ONLY( compare_lt_and_branch_impl: )
				IFCMP_TWO_VALUES(<, core->compare(a1,a2) == trueAtom, a1, a2, i1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$16" string="ifle">
			<short>Branch if the first value is less than or equal to the second value.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="2" out_count="0"><![CDATA[ _ , value1, value2 => _ ]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump if value1 is less than or equal to value2.
Compute value2 < value1 using the abstract relational comparison algorithm in ECMA-262
section 11.8.5. If the result of the comparison is false, jump the number of bytes indicated
by offset. Otherwise continue executing code from this point.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				LOAD_OFFSET_AND_FETCH_SS(a1,a2,i1);
			PEEPHOLE_ONLY( compare_le_and_branch_impl: )
				IFCMP_TWO_VALUES(<=, core->compare(a2, a1) == falseAtom,a1,a2,i1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$17" string="ifgt">
			<short>Branch if the first value is greater than the second value.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="2" out_count="0"><![CDATA[ _ , value1, value2 => _ ]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump if value1 is greater than or equal to value2.
Compute value2 < value1 using the abstract relational comparison algorithm in ECMA-262
section 11.8.5. If the result of the comparison is true, jump the number of bytes indicated
by offset. Otherwise continue executing code from this point.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				LOAD_OFFSET_AND_FETCH_SS(a1,a2,i1);
			PEEPHOLE_ONLY( compare_gt_and_branch_impl: )
				IFCMP_TWO_VALUES(>, core->compare(a2, a1) == trueAtom,a1,a2,i1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$18" string="ifge">
			<short>Branch if the first value is greater than or equal to the second value.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="2" out_count="0"><![CDATA[ _ , value1, value2 => _ ]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump if value1 is greater than or equal to value2.
Compute value1 < value2 using the abstract relational comparison algorithm in ECMA-262
section 11.8.5. If the result of the comparison is false, jump the number of bytes indicated
by offset. Otherwise continue executing code from this point.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				LOAD_OFFSET_AND_FETCH_SS(a1,a2,i1);
			PEEPHOLE_ONLY( compare_ge_and_branch_impl: )
				IFCMP_TWO_VALUES(>=, core->compare(a1, a2) == falseAtom,a1,a2,i1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$19" string="ifstricteq">
			<short>Branch if the first value is equal to the second value.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="2" out_count="0"><![CDATA[ _ , value1, value2 => _ ]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump if value1 is equal to value2.
Compute value1 === value2 using the strict equality comparison algorithm in ECMA-262
section 11.9.6. If the result of the comparison is true, jump the number of bytes indicated
by offset. Otherwise continue executing code from this point.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				LOAD_OFFSET_AND_FETCH_SS(a1,a2,i1);
			PEEPHOLE_ONLY( compare_stricteq_and_branch_impl: )
				IFCMP_TWO_VALUES(==, core->stricteq(a1,a2) == trueAtom, a1, a2, i1);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$1A" string="ifstrictne">
			<short>Branch if the first value is not equal to the second value.</short>
			<params>
				<param name="offset" type="s24" class="jump"/>
			</params>
			<stack in_count="2" out_count="0"><![CDATA[ _ , value1, value2 => _ ]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/></stack>
			<description>
				<![CDATA[
offset is an s24 that is the number of bytes to jump if value1 is not equal to value2.
Compute value1 === value2 using the strict equality comparison algorithm in ECMA-262
section 11.9.6. If the result of the comparison is false, jump the number of bytes indicated
by offset. Otherwise continue executing code from this point.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				LOAD_OFFSET_AND_FETCH_SS(a1,a2,i1);
			PEEPHOLE_ONLY( compare_strictne_and_branch_impl: )
				IFNCMP_TWO_VALUES(==, core->stricteq(a1,a2) == trueAtom, a1, a2, i1);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIC" hex="$1B" string="lookupswitch">
			<short>Jump to different locations based on an index.</short>
			<params>
				<param name="default_offset" type="s24" class="jump"/>
				<param name="case_count" type="u30" class="switch_count"/>
				<param name="case_offsets" type="s24" countp="case_count" class="case_offsets"/>
			</params>
			<stack in_count="1" out_count="0"><![CDATA[ _ , index => _ ]]><sparam name="index" class="in"/></stack>
			<description>
				<![CDATA[
default_offset is an s24 that is the offset to jump, in bytes, for the default case. case_offsets are
each an s24 that is the offset to jump for a particular index. There are case_count+1 case
offsets. 

case_count is a u30.

index is popped off of the stack and must be of type int. If index is less than zero or greater
than case_count, the target is calculated by adding default_offset to the base location.
Otherwise the target is calculated by adding the case_offset at position index to the base
location. Execution continues from the target location.

The base location is the address of the lookupswitch instruction itself.

Notes

Other control flow instructions take the base location to be the address of the following
instruction.

]]>
			</description>
			<tamarincode>
				<![CDATA[
				const uint8_t* base = pc-1;
				// safe to assume int since verifier checks for int
				uint32_t index = AvmCore::integer_i(*(sp--));
				const uint8_t* switch_pc = pc+3;
				uint32_t case_count = uint32_t(readU30(switch_pc)) + 1;
                pc = base+readS24( index < case_count ? (switch_pc + 3*index) : pc );
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$1C" string="pushwith">
			<short>Push a with scope onto the scope stack</short>
			<params></params>
			<stack in_count="1" out_count="0"><![CDATA[ _ , scope_obj => _ ]]><sparam name="scope_obj" class="in"/></stack>
			<description>
				<![CDATA[
scope_obj is popped off of the stack, and the object is pushed onto the scope stack. scope_obj can be of
any type.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[0]; // scope object
				sp--;
				if (AvmCore::isNullOrUndefined(a1)) {
					SAVE_EXPC;
					env->nullcheck(a1);
				}
				if (!withBase)
					withBase = scopeBase+scopeDepth;
				// is it possible to have pushWith for scope 0? not sure, let's do this just in case
				if (scopeDepth == 0 && globalScope == NULL)
				{
					AvmAssert(scope->getSize() == 0);
					globalScope = AvmCore::atomToScriptObject(a1);
				}
				scopeBase[scopeDepth++] = a1;
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$1D" string="popscope">
			<short>Pop a scope off of the scope stack</short>
			<params></params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[
Pop the top scope off of the scope stack and discards it.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				if (!--scopeDepth)
				{
					if (scope->getSize() == 0)
						globalScope = NULL;
				}
            #ifdef DEBUGGER
                // in debugger builds, ensure that non-active scope entries are nulled out
                scopeBase[scopeDepth] = nullObjectAtom;
            #endif
				if (withBase >= scopeBase + scopeDepth)
					withBase = NULL;
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$1E" string="nextname">
			<short>Get the name of the next property when iterating over an object.</short>
			<params></params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , obj, index => _ , name]]><sparam name="obj" class="in"/><sparam name="index" class="in"/><sparam name="name" class="out"/></stack>
			<description>
				<![CDATA[
index and obj are popped off of the stack. index must be a value of type int. Gets the name of
the property that is at position index + 1 on the object obj, and pushes it onto the stack.

Notes

index will usually be the result of executing hasnext on obj.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
				// verifier checks for int
				sp[0] = env->nextname(a1, AvmCore::integer_i(a2));
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$1F" string="hasnext">
			<short>Determine if the given object has any more properties.</short>
			<params></params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , obj, cur_index => _ , next_index]]><sparam name="obj" class="in"/><sparam name="cur_index" class="in"/><sparam name="next_index" class="out"/></stack>
			<description>
				<![CDATA[
cur_index and obj are popped off of the stack. cur_index must be of type int. Get the index of
the next property after the property at cur_index. If there are no more properties, then the
result is 0. The result is pushed onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
				// verifier checks for int
				sp[0] = core->intToAtom(env->hasnext(a1, AvmCore::integer_i(a2)));
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$20" string="pushnull">
			<short>Push null.</short>
			<params></params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , null]]><sparam name="null" class="out"/></stack>
			<description>
				<![CDATA[
Push the null value onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                *(++sp) = nullObjectAtom;
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$21" string="pushundefined">
			<short>Push undefined.</short>
			<params></params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , undefined]]><sparam name="undefined" class="out"/></stack>
			<description>
				<![CDATA[
Push the undefined value onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                *(++sp) = undefinedAtom;
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$22" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="III" hex="$23" string="nextvalue">
			<short>Get the name of the next property when iterating over an object.</short>
			<params></params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , obj, index => _ , value]]><sparam name="obj" class="in"/><sparam name="index" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
index and obj are popped off of the stack. index must be of type int. Get the value of the
property that is at position index + 1 on the object obj, and pushes it onto the stack.
Notes
Index will usually be the result of executing hasnext on obj.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
				// verifier checks for int
				sp[0] = env->nextvalue(a1, AvmCore::integer_i(a2));
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$24" string="pushbyte">
			<short>Push a byte value.</short>
			<params>
				<param name="byte_value" type="u8" class="integer"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
byte_value is an unsigned byte. The byte_value is promoted to an int, and the result is pushed
onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				*(++sp) = MAKE_INTEGER((int8_t)U8ARG);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$25" string="pushshort">
			<short>Push a short value.</short>
			<params>
				<param name="value" type="u30" class="integer"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
value is a u30. The value is pushed onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                // this just pushes an integer since we dont have short atoms
                *(++sp) = MAKE_INTEGER(((int16_t)U30ARG));
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$26" string="pushtrue">
			<short>Push true.</short>
			<params></params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , true ]]><sparam name="true" class="out"/></stack>
			<description>
				<![CDATA[
Push the true value onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				*(++sp) = trueAtom;
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$27" string="pushfalse">
			<short>Push false.</short>
			<params></params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , false]]><sparam name="false" class="out"/></stack>
			<description>
				<![CDATA[
Push the false onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                *(++sp) = falseAtom;
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$28" string="pushnan">
			<short>Push NaN.</short>
			<params></params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , NaN]]><sparam name="NaN" class="out"/></stack>
			<description>
				<![CDATA[
Push the value NaN onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				*(++sp) = core->kNaN;
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$29" string="pop">
			<short>Pop the top value from the stack.</short>
			<params></params>
			<stack in_count="1" out_count="0"><![CDATA[ _ , value => _ ]]><sparam name="value" class="in"/></stack>
			<description>
				<![CDATA[
Pops the top value from the stack and discards it.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                sp--;
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$2A" string="dup">
			<short>Duplicates the top value on the stack.</short>
			<params></params>
			<stack in_count="1" out_count="2"><![CDATA[ _ , value => _ , value, value]]><sparam name="value" class="in"/><sparam name="value" class="out"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
Duplicates the top value of the stack, and then pushes the duplicated value onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				sp++;
				sp[0] = sp[-1];
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$2B" string="swap">
			<short>Duplicates the top value on the stack.</short>
			<params></params>
			<stack in_count="2" out_count="2"><![CDATA[ _ , value1, value2 => _ , value2, value1]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value2" class="out"/><sparam name="value1" class="out"/></stack>
			<description>
				<![CDATA[
Swap the top two values on the stack. Pop value2 and value1. Push value2, then push value1.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                a1 = sp[0];
                sp[0] = sp[-1];
                sp[-1] = a1;
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$2C" string="pushstring">
			<short>Push a string value onto the stack.</short>
			<params>
				<param name="index" type="u30" class="string"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the string constant pool. The string value at index
in the string constant pool is pushed onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                *(++sp) = pool->getString((uint32_t)U30ARG)->atom();
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$2D" string="pushint">
			<short>Push an int value onto the stack.</short>
			<params>
				<param name="index" type="u30" class="integer"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the integer constant pool. The int value at index in
the integer constant pool is pushed onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                *(++sp) = core->intToAtom(pool->cpool_int[(uint32_t)U30ARG]);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$2E" string="pushuint">
			<short>Push an unsigned int value onto the stack.</short>
			<params>
				<param name="index" type="u30" class="integer"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the unsigned integer constant pool. The value at
index in the unsigned integer constant pool is pushed onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                *(++sp) = core->uintToAtom(pool->cpool_uint[(uint32_t)U30ARG]);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$2F" string="pushdouble">
			<short>Push a double value onto the stack.</short>
			<params>
				<param name="index" type="u30" class="integer"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the double constant pool. The double value at
index in the double constant pool is pushed onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                *(++sp) = kDoubleType|(uintptr_t)cpool_double[(uint32_t)U30ARG];
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$30" string="pushscope">
			<short>Push an object onto the scope stack.</short>
			<params></params>
			<stack in_count="1" out_count="0"><![CDATA[ _ , value => _ ]]><sparam name="value" class="in"/></stack>
			<description>
				<![CDATA[
Pop value off of the stack. Push value onto the scope stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[0]; // scope
				sp--;
				if (AvmCore::isNullOrUndefined(a1)) {
					SAVE_EXPC;
					env->nullcheck(a1);
				}
				if (scopeDepth == 0 && globalScope == NULL)
				{
					AvmAssert(scope->getSize() == 0);
					globalScope = AvmCore::atomToScriptObject(a1);
				}
				scopeBase[scopeDepth++] = a1;
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$31" string="pushnamespace">
			<short>Push a namespace.</short>
			<params>
				<param name="index" type="u30" class="namespace"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , namespace]]><sparam name="namespace" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the namespace constant pool. The namespace value
at index in the namespace constant pool is pushed onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                *(++sp) = pool->cpool_ns[(uint32_t)U30ARG]->atom();
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$32" string="hasnext2">
			<short>Determine if the given object has any more properties.</short>
			<params>
				<param name="object_reg" type="u30" class="integer"/>
				<param name="index_reg" type="u30" class="jump"/>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , => _ , value]]><sparam name="" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
object_reg and index_reg are uints that must be indexes to a local register. The value of the
register at position object_reg is the object that is being enumerated and is assigned to obj.
The value of the register at position index_reg must be of type int, and that value is assigned
to cur_index.

Get the index of the next property after the property located at index cur_index on object
obj. If there are no more properties on obj, then obj is set to the next object on the prototype
chain of obj, and cur_index is set to the first index of that object. If there are no more objects
on the prototype chain and there are no more properties on obj, then obj is set to null, and
cur_index is set to 0.

The register at position object_reg is set to the value of obj, and the register at position
index_reg is set to the value of cur_index.
If index is not 0, then push true. Otherwise push false.

Notes

hasnext2 works by reference. Each time it is executed it changes the values of local registers
rather than simply returning a new value. This is because the object being enumerated can
change when it is necessary to walk up the prototype chain to find more properties. This is
different from how hasnext works, though the two may seem similar due to the similar
names.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				u1 = U30ARG;                       // objReg
				u2  = U30ARG;                      // indexReg
				a1l = framep[u1];                  // objAtom
				i32l = AvmCore::integer(framep[u2]);  // index
				*(++sp) = env->hasnextproto(a1l, i32l) ? trueAtom : falseAtom;
				framep[u1] = a1l;
				framep[u2] = core->intToAtom(i32l);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$33" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$34" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="IIM" hex="$35" string="li8">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="IIM" hex="$36" string="li16">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="IIM" hex="$37" string="li32">
			<short>Load a 32bit integer from global memory to local stack.</short>

			<stack in_count="0" out_count="0">
				<sparam name="addr" class="in"/>
				<sparam name="value" class="out"/>

			</stack>


			<tamarincode>
		<![CDATA[
			i1 = AvmCore::integer(sp[0]);		// i1 = addr
			MOPS_LOAD(i1, int32_t, li32, i32l);	// i32l = result
			sp[0] = core->intToAtom(i32l);
			NEXT;
]]>
			</tamarincode>

		</opcode>
		<opcode type="IIM" hex="$38" string="lf32">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="IIM" hex="$39" string="lf64">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="IIM" hex="$3A" string="si8">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="IIM" hex="$3B" string="si16">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="IIM" hex="$3C" string="si32">
			<short>Store a 32bit integer into global memory.</short>

			<stack in_count="2" out_count="0">
				<sparam name="addr" class="in"/>
				<sparam name="value" class="in"/>
			</stack>

			<tamarincode>
		<![CDATA[
			i1 = AvmCore::integer(sp[0]);		// i1 = addr
			i32l = AvmCore::integer(sp[-1]);	// i32l = value
			MOPS_STORE(i1, uint32_t, si32, i32l);

			sp -= 2;
			NEXT;
]]>
			</tamarincode>

		</opcode>
		<opcode type="IIM" hex="$3D" string="sf32">
					<stack in_count="0" out_count="0"></stack>
		</opcode>
		
		<opcode type="IIM" hex="$3E" string="sf64">
		
		<short>Store an 64bit number into  global memory</short>
		
			<stack in_count="2" out_count="0">
				<sparam name="index" class="in" /> 
				<sparam name="d2l"  class="in" /> 			
			</stack>
		
		<tamarincode>
				i1 = AvmCore::integer(sp[0]);
				d2l = AvmCore::number(sp[-1]);
				MOPS_STORE(i1, double, sf64, d2l);
				sp -= 2;
				NEXT;	
 
				...
				
#define     MOPS_STORE(addr, type, call, value) \
            MOPS_RANGE_CHECK(addr, type) \
            union { uint8_t* p8; type* p; }; \
            p8 = envDomain->globalMemoryBase() + (addr); \
            *p = (type)(value);
#endif

				
		</tamarincode>	
		
		</opcode>
		<opcode type="UNU" hex="$3F" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="III" hex="$40" string="newfunction">
			<short>Create a new function object.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , function_obj]]><sparam name="function_obj" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index of a method_info. A new function object is created
from that method_info and pushed onto the stack. For a description of creating a new
function object, see ECMA-262 section 13.2.
When creating the new function object the scope stack used is the current scope stack when
this instruction is executed, and the body is the method_body entry that references the
specified method_info entry.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				sp++;
				MethodInfo *body = pool->getMethodInfo((uint32_t)U30ARG);
				sp[0] = env->newfunction(body, scope, scopeBase)->atom();
                NEXT; 
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$41" string="call">
			<short>Call a closure.</short>
			<params>
				<param name="arg_count" type="u30" class="integer"/>
			</params>
			<stack in_count="6" out_count="1"><![CDATA[ _ , function, receiver, arg1, arg2, ..., argn => _ , value]]><sparam name="function" class="in"/><sparam name="receiver" class="in"/><sparam name="arg1" class="in"/><sparam name="arg2" class="in"/><sparam name="..." class="in"/><sparam name="argn" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
arg_count is a u30 that is the number of arguments present on the stack for the call. function
is the closure that is being called. receiver is the object to use for the "this" value. This will
invoke the [[Call]] property on function with the arguments receiver, arg1, ..., argn. The
result of invoking the [[Call]] property will be pushed onto the stack.
Runtime exceptions
A TypeError is thrown if function is not a Function.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
                i1 = (intptr_t)U30ARG; // argc
                // stack in: function, receiver, arg1, ... argN
                // stack out: result
                a1 = toplevel->op_call(sp[-i1-1]/*function*/, (int32_t)i1, sp-i1);
                *(sp = sp-i1-1) = a1;
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$42" string="construct">
			<short>Construct an instance.</short>
			<params>
				<param name="arg_count" type="u30" class="integer"/>
			</params>
			<stack in_count="6" out_count="1"><![CDATA[ _ , function, receiver, arg1, arg2, ..., argn => _ , value]]><sparam name="function" class="in"/><sparam name="receiver" class="in"/><sparam name="arg1" class="in"/><sparam name="arg2" class="in"/><sparam name="..." class="in"/><sparam name="argn" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
arg_count is a u30 that is the number of arguments present on the stack. object is the
function that is being constructed. This will invoke the [[Construct]] property on object with
the given arguments. The new instance generated by invoking [[Construct]] will be pushed
onto the stack.

Runtime exceptions

A TypeError is thrown if object does not implement the [[Construct]] property.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
                i1 = (intptr_t)U30ARG;  // argc
                // stack in: function, arg1, ..., argN
                // stack out: new instance
                a1 = toplevel->op_construct(sp[-i1]/*function*/, (int32_t)i1, sp-i1);
                *(sp = sp-i1) = a1;
                NEXT; 
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$43" string="callmethod">
			<short>Call a method identified by index in the object's method table.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
				<param name="arg_count" type="u30" class="integer"/>
			</params>
			<stack in_count="5" out_count="1"><![CDATA[ _ , receiver, arg1, arg2, ..., argn => _ , value]]><sparam name="receiver" class="in"/><sparam name="arg1" class="in"/><sparam name="arg2" class="in"/><sparam name="..." class="in"/><sparam name="argn" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that is the index of the method to invoke on receiver. arg_count is a u30 that is
the number of arguments present on the stack. receiver is the object to invoke the method
on.
The method at position index on the object receiver, is invoked with the arguments receiver,
arg1, ..., argn. The result of the method call is pushed onto the stack.

Runtime exceptions

A TypeError is thrown if receiver is null or undefined.
An ArgumentError is thrown if the number of arguments does not match the expected
number of arguments for the method.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				// stack in: receiver, arg1..N
				// stack out: result
				u1 = U30ARG-1;         // disp_id
				i2 = (intptr_t)U30ARG; // argc
				a2p = sp-i2;           // atomv

				// must be a real class instance for this to be used.  primitives that have
				// methods will only have final bindings and no dispatch table.
				VTable* vtable = toplevel->toVTable(a2p[0]); // includes null check
				AvmAssert(u1 < vtable->traits->getTraitsBindings()->methodCount);
				f = vtable->methods[u1];
				// ISSUE if arg types were checked in verifier, this coerces again.
				a1 = f->coerceEnter((int32_t)i2, a2p);
				*(sp -= i2) = a1;
				NEXT; 
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$44" string="callstatic">
			<short>Call a method identified by index in the abcFile method table.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
				<param name="arg_count" type="u30" class="integer"/>
			</params>
			<stack in_count="5" out_count="1"><![CDATA[ _ , receiver, arg1, arg2, ..., argn => _ , value]]><sparam name="receiver" class="in"/><sparam name="arg1" class="in"/><sparam name="arg2" class="in"/><sparam name="..." class="in"/><sparam name="argn" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that is the index of the method_info of the method to invoke. arg_count is a
u30 that is the number of arguments present on the stack. receiver is the object to invoke the
method on.

The method at position index is invoked with the arguments receiver, arg1, ..., argn. The
receiver will be used as the "this" value for the method. The result of the method is pushed
onto the stack.

Runtime exceptions

A TypeError is thrown if receiver is null or undefined.
An ArgumentError is thrown if the number of arguments does not match the expected
number of arguments for the method.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				// stack in: receiver, arg1..N
				// stack out: result
				u1 = U30ARG;            // method_id
				i2 = (intptr_t)U30ARG;  // argc
				env->nullcheck(sp[-i2]);
				// ISSUE if arg types were checked in verifier, this coerces again.
				f = env->abcEnv()->getMethod((uint32_t)u1);
				a1 = f->coerceEnter((int32_t)i2, sp-i2);
				*(sp -= i2) = a1;
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$45" string="callsuper">
			<short>Call a method on a base class.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
				<param name="arg_count" type="u30" class="integer"/>
			</params>
			<stack in_count="6" out_count="1"><![CDATA[ _ , receiver, [ns], [name], arg1,...,argn => _ , value]]><sparam name="receiver" class="in"/><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="arg1" class="in"/><sparam name="..." class="in"/><sparam name="argn" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
arg_count is a u30 that is the number of arguments present on the stack. The number of
arguments specified by arg_count are popped off the stack and saved.
index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime.
receiver is the object to invoke the method on.

The base class of receiver is determined and the method indicated by the multiname is
resolved in the declared traits of the base class. The method is invoked with the arguments
receiver, arg1, ..., argn. The receiver will be used as the "this" value for the method. The result
of the method call is pushed onto the stack.

Runtime exceptions

A TypeError is thrown if receiver is null or undefined.
An ArgumentError is thrown if the number of arguments does not match the expected
number of arguments for the method.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				u1 = WORD_CODE_ONLY(WOP_callsuper) ABC_CODE_ONLY(OP_callsuper);
callsuper_impl:
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				i1 = (intptr_t)U30ARG; /* argc */
				sp -= i1;
				a2p = sp; /* atomv */
				if (multiname->isRuntime())
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultiname(env, aux_memory->multiname2, sp);
					multiname = &aux_memory->multiname2;
					a2p[0] = *sp;
				}
				env->nullcheck(a2p[0]);
				*sp = env->callsuper(multiname, (int32_t)i1, a2p);
				if (u1 == WORD_CODE_ONLY(WOP_callsupervoid) ABC_CODE_ONLY(OP_callsupervoid))
					sp--;
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$46" string="callproperty">
			<short>Call a property.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
				<param name="arg_count" type="u30" class="integer"/>
			</params>
			<stack in_count="6" out_count="1"><![CDATA[ _ , obj, [ns], [name], arg1,...,argn => _ , value]]><sparam name="obj" class="in"/><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="arg1" class="in"/><sparam name="..." class="in"/><sparam name="argn" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
arg_count is a u30 that is the number of arguments present on the stack. The number of
arguments specified by arg_count are popped off the stack and saved.
index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime.
receiver is the object to invoke the method on.

The base class of receiver is determined and the method indicated by the multiname is
resolved in the declared traits of the base class. The method is invoked with the arguments
receiver, arg1, ..., argn. The receiver will be used as the "this" value for the method. The result
of the method call is pushed onto the stack.

Runtime exceptions

A TypeError is thrown if receiver is null or undefined.
An ArgumentError is thrown if the number of arguments does not match the expected
number of arguments for the method.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				u1 = WORD_CODE_ONLY(WOP_callsuper) ABC_CODE_ONLY(OP_callsuper);
callsuper_impl:
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				i1 = (intptr_t)U30ARG; /* argc */
				sp -= i1;
				a2p = sp; /* atomv */
				if (multiname->isRuntime())
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultiname(env, aux_memory->multiname2, sp);
					multiname = &aux_memory->multiname2;
					a2p[0] = *sp;
				}
				env->nullcheck(a2p[0]);
				*sp = env->callsuper(multiname, (int32_t)i1, a2p);
				if (u1 == WORD_CODE_ONLY(WOP_callsupervoid) ABC_CODE_ONLY(OP_callsupervoid))
					sp--;
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$47" string="returnvoid">
			<short>Return from a method.</short>
			<params>
			</params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[
Return from the currently executing method. This returns the value undefined. If the
method has a return type, then undefined is coerced to that type and then returned.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = undefinedAtom;
				goto return_value_from_interpreter;
return_value_from_interpreter:
				SAVE_EXPC;
				a1 = toplevel->coerce(a1, ms->returnTraits()); 
				return a1;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$48" string="returnvalue">
			<short>Return a value from a method.</short>
			<params>
			</params>
			<stack in_count="5" out_count="0"><![CDATA[ _ , object, arg1, arg2, ..., argn => _ ]]><sparam name="object" class="in"/><sparam name="arg1" class="in"/><sparam name="arg2" class="in"/><sparam name="..." class="in"/><sparam name="argn" class="in"/></stack>
			<description>
				<![CDATA[
arg_count is a u30 that is the number of arguments present on the stack. This will invoke the
constructor on the base class of object with the given arguments.

Runtime exceptions

A TypeError is thrown if object is null or undefined.

]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = *sp;
return_value_from_interpreter:
				SAVE_EXPC;
				a1 = toplevel->coerce(a1, ms->returnTraits());
				return a1;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$49" string="constructsuper">
			<short>Construct an instance of the base class.</short>
			<params>
				<param name="arg_count" type="u30" class="integer"/>
			</params>
			<stack in_count="5" out_count="0"><![CDATA[ _ , object, arg1, arg2, ..., argn => _ ]]><sparam name="object" class="in"/><sparam name="arg1" class="in"/><sparam name="arg2" class="in"/><sparam name="..." class="in"/><sparam name="argn" class="in"/></stack>
			<description>
				<![CDATA[
arg_count is a u30 that is the number of arguments present on the stack. This will invoke the
constructor on the base class of object with the given arguments.

Runtime exceptions

A TypeError is thrown if object is null or undefined.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				// stack in:  obj arg1..N
				// stack out: 
				i1 = (intptr_t)U30ARG;  // argc
				env->nullcheck(sp[-i1]);
				env->super_init()->coerceEnter((int32_t)i1, sp-i1);
				sp -= i1+1;
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$4A" string="constructprop">
			<short>Construct a property.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
				<param name="arg_count" type="u30" class="integer"/>
			</params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[
arg_count is a u30 that is the number of arguments present on the stack. The number of
arguments specified by arg_count are popped off the stack and saved.

index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime.
obj is the object to resolve the multiname in.

The property specified by the multiname at index is resolved on the object obj. The
[[Construct]] property is invoked on the value of the resolved property with the arguments
obj, arg1, ..., argn. The new instance generated by invoking [[Construct]] will be pushed
onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = *sp;
return_value_from_interpreter:
				SAVE_EXPC;
				a1 = toplevel->coerce(a1, ms->returnTraits());
				return a1;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$4B" string="Unused">
			<short>OP_callsuperid</short>
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="III" hex="$4C" string="callproplex">
			<short>Call a property.</short>
			<params>
				<param name="arg_count" type="u30" class="integer"/>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="6" out_count="1"><![CDATA[ _ , obj, [ns], [name], arg1,...,argn => _ , value]]><sparam name="obj" class="in"/><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="arg1" class="in"/><sparam name="..." class="in"/><sparam name="argn" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
arg_count is a u30 that is the number of arguments present on the stack. The number of
arguments specified by arg_count are popped off the stack and saved.
index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime.
obj is the object to resolve and call the property on.
The property specified by the multiname at index is resolved on the object obj. The [[Call]]
property is invoked on the value of the resolved property with the arguments null, arg1, ...,
argn. The result of the call is pushed onto the stack.

Runtime exceptions

A TypeError is thrown if obj is null or undefined or if the property specified by the
multiname is null or undefined.

An ArgumentError is thrown if the number of arguments does not match the expected
number of expected arguments for the method.

]]>
			</description>
			<tamarincode>
				<![CDATA[
				u1 = WORD_CODE_ONLY(WOP_callproplex) ABC_CODE_ONLY(OP_callproplex);
				goto callproperty_impl; 
	callproperty_impl:				
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				i1 = (intptr_t)U30ARG; /* argc */
				a2p = sp - i1; /* atomv */
				sp = a2p;
				if (multiname->isRuntime())
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultiname(env, aux_memory->multiname2, sp);
					multiname = &aux_memory->multiname2;
				}
				a1 = *sp; /* base */
				if (u1 == WORD_CODE_ONLY(WOP_callproplex) ABC_CODE_ONLY(OP_callproplex))
					a2p[0] = nullObjectAtom;
				*sp = toplevel->callproperty(a1, multiname, (int32_t)i1, a2p, toplevel->toVTable(a1));
				if (u1 == WORD_CODE_ONLY(WOP_callpropvoid) ABC_CODE_ONLY(OP_callpropvoid))
					sp--;
				NEXT;				
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$4D" string="Unused">
			<short>OP_callinterface</short>
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="III" hex="$4E" string="callsupervoid">
			<short>Call a method on a base class, discarding the return value.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
				<param name="arg_count" type="u30" class="integer"/>
			</params>
			<stack in_count="5" out_count="0"><![CDATA[ _ , receiver, [ns], [name], arg1, _ , argn => _ ]]><sparam name="receiver" class="in"/><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="arg1" class="in"/><sparam name="argn" class="in"/></stack>
			<description>
				<![CDATA[
arg_count is a u30 that is the number of arguments present on the stack. The number of
arguments specified by arg_count are popped off the stack and saved.

index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime.
receiver is the object to invoke the method on.

The base class of receiver is determined and the method indicated by the multiname is
resolved in the declared traits of the base class. The method is invoked with the arguments
receiver, arg1, ..., argn. The first argument will be used as the "this" value for the method.
The result of the method is discarded.

Runtime exceptions

A TypeError is thrown if receiver is null or undefined.
An ArgumentError is thrown if the number of arguments does not match the expected
number of arguments for the method.

]]>
			</description>
			<tamarincode>
				<![CDATA[
				u1 = WORD_CODE_ONLY(WOP_callsupervoid) ABC_CODE_ONLY(OP_callsupervoid);
				goto callsuper_impl; 
		callsuper_impl:				
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				i1 = (intptr_t)U30ARG; /* argc */
				sp -= i1;
				a2p = sp; /* atomv */
				if (multiname->isRuntime())
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultiname(env, aux_memory->multiname2, sp);
					multiname = &aux_memory->multiname2;
					a2p[0] = *sp;
				}
				env->nullcheck(a2p[0]);
				*sp = env->callsuper(multiname, (int32_t)i1, a2p);
				if (u1 == WORD_CODE_ONLY(WOP_callsupervoid) ABC_CODE_ONLY(OP_callsupervoid))
					sp--;
				NEXT;				
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$4F" string="callpropvoid">
			<short>Call a property, discarding the return value.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
				<param name="arg_count" type="u30" class="integer"/>
			</params>
			<stack in_count="6" out_count="0"><![CDATA[ _ , obj, [ns], [name], arg1,...,argn => _ ]]><sparam name="obj" class="in"/><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="arg1" class="in"/><sparam name="..." class="in"/><sparam name="argn" class="in"/></stack>
			<description>
				<![CDATA[
arg_count is a u30 that is the number of arguments present on the stack. The number of
arguments specified by arg_count are popped off the stack and saved.

index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime.
obj is the object to resolve and call the property on.

The property specified by the multiname at index is resolved on the object obj. The [[Call]]
property is invoked on the value of the resolved property with the arguments obj, arg1, ...,
argn. The result of the call is discarded.

Runtime exceptions

A TypeError is thrown if obj is null or undefined or if the property specified by the
multiname is null or undefined.
An ArgumentError is thrown if the number of arguments does not match the expected
number of expected arguments for the method.

]]>
			</description>
			<tamarincode>
				<![CDATA[
				u1 = WORD_CODE_ONLY(WOP_callpropvoid) ABC_CODE_ONLY(OP_callpropvoid);
				goto callproperty_impl;
				
		callproperty_impl:
			
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				i1 = (intptr_t)U30ARG; /* argc */
				a2p = sp - i1; /* atomv */
				sp = a2p;
				if (multiname->isRuntime())
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultiname(env, aux_memory->multiname2, sp);
					multiname = &aux_memory->multiname2;
				}
				a1 = *sp; /* base */
				if (u1 == WORD_CODE_ONLY(WOP_callproplex) ABC_CODE_ONLY(OP_callproplex))
					a2p[0] = nullObjectAtom;
				*sp = toplevel->callproperty(a1, multiname, (int32_t)i1, a2p, toplevel->toVTable(a1));
				if (u1 == WORD_CODE_ONLY(WOP_callpropvoid) ABC_CODE_ONLY(OP_callpropvoid))
					sp--;
				NEXT;				
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$50" string="sxi1">
			<short>Sign extends. (Undocumented)</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ value => value]]><sparam name="_value" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
sign extends -- results always fit into an atom, no need to call intToAtom
since we are downshifting anyway, integrate final upshift-by-3 into downshift
rather than using MAKE_INTEGER macro. 
]]>
			</description>
			<tamarincode>
				<![CDATA[
				i1 = AvmCore::integer(sp[0]);
				sp[0] = CHECK_INT_ATOM(Atom(((i1 << (8*sizeof(Atom)-1)) >> ((8*sizeof(Atom)-1)-3)) | kIntptrType));
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$51" string="sxi8">
			<short>Sign extends 8bit. (Undocumented)</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ value => value]]><sparam name="_value" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
sign extends -- results always fit into an atom, no need to call intToAtom
since we are downshifting anyway, integrate final upshift-by-3 into downshift
rather than using MAKE_INTEGER macro. 
]]>
			</description>
			<tamarincode>
				<![CDATA[
				i1 = AvmCore::integer(sp[0]);
				sp[0] = CHECK_INT_ATOM(Atom(((i1 << (8*(sizeof(Atom)-1))) >> ((8*(sizeof(Atom)-1))-3)) | kIntptrType));
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$52" string="sxi16">
			<short>Sign extends 16bit. (Undocumented)</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ value => value]]><sparam name="_value" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
sign extends -- results always fit into an atom, no need to call intToAtom
since we are downshifting anyway, integrate final upshift-by-3 into downshift
rather than using MAKE_INTEGER macro. 
]]>
			</description>
			<tamarincode>
				<![CDATA[
				sp[0] = CHECK_INT_ATOM(Atom(((i1 << (8*(sizeof(Atom)-2))) >> ((8*(sizeof(Atom)-2))-3)) | kIntptrType));
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$53" string="applytype">
			<short>Apply Type. (Undocumented)</short>
			<params>
				<param name="paramcount" type="u30" class="integer"/>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ arg1, .. argN => value]]><sparam name="_arg1" class="in"/><sparam name="..argN" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
used to create concrete class objects for parameterizations of Vector
 in: factory arg1..N
 out: type 
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				i1 = (intptr_t)U30ARG;  // argc
				// stack in: factory, arg1, ... argN
				// stack out: result
				a1 = op_applytype(env, sp[-i1]/*function*/, (int32_t)i1, sp-i1+1);
				*(sp = sp-i1) = a1;
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$54" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="III" hex="$55" string="newobject">
			<short>Create a new object.</short>
			<params>
				<param name="arg_count" type="u30" class="integer"/>
			</params>
			<stack in_count="7" out_count="1"><![CDATA[ _ , name1, value1, name2, value2,...,nameN, valueN => _ , newobj]]><sparam name="name1" class="in"/><sparam name="value1" class="in"/><sparam name="name2" class="in"/><sparam name="value2" class="in"/><sparam name="..." class="in"/><sparam name="nameN" class="in"/><sparam name="valueN" class="in"/><sparam name="newobj" class="out"/></stack>
			<description>
				<![CDATA[
arg_count is a u30 that is the number of properties that will be created in newobj. There will
be a total of arg_count name values on the stack, which will be of type String (name1 to
nameN). There will be an equal number of values on the stack, which can be of any type,
and will be the initial values for the properties

A new value of type Object is created and assigned to newobj. The properties specified on the
stack will be dynamically added to newobj. The names of the properties will be name1,
name2,..., nameN and these properties will be set to the corresponding values (value1,
value2,..., valueN). newobj is then pushed onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
                i1 = (intptr_t)U30ARG;
                a1 = env->op_newobject(sp, (int)i1)->atom();
                *(sp -= 2*i1-1) = a1;
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$56" string="newarray">
			<short>Create a new array.</short>
			<params>
				<param name="arg_count" type="u30" class="integer"/>
			</params>
			<stack in_count="4" out_count="1"><![CDATA[ _ , value1, value2, ..., valueN => _ , newarray]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="..." class="in"/><sparam name="valueN" class="in"/><sparam name="newarray" class="out"/></stack>
			<description>
				<![CDATA[
arg_count is a u30 that is the number of entries that will be created in the new array. There
will be a total of arg_count values on the stack.

A new value of type Array is created and assigned to newarray. The values on the stack will
be assigned to the entries of the array, so newarray[0] = value1, newarray[1] = value2, ....,
newarray[N-1] = valueN. newarray is then pushed onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
                i1 = (intptr_t)U30ARG;
                a1 = avmplus::newarray(toplevel, (int)i1, sp-i1+1)->atom();
                *(sp -= i1-1) = a1;
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$57" string="newactivation">
			<short>Create a new activation object.</short>
			<params>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , newactivation]]><sparam name="newactivation" class="out"/></stack>
			<description>
				<![CDATA[
Creates a new activation object, newactivation, and pushes it onto the stack. Can only be
used in methods that have the NEED_ACTIVATION flag set in their MethodInfo entry.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				*(++sp) = env->newActivation()->atom();
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$58" string="newclass">
			<short>Create a new class.</short>
			<params>
				<param name="index" type="u30" class="classinfo"/>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , basetype => _ , newclass]]><sparam name="basetype" class="in"/><sparam name="newclass" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that is an index of the ClassInfo that is to be created. basetype must be the
base class of the class being created, or null if there is no base class.

The class that is represented by the ClassInfo at position index of the ClassInfo entries is
created with the given basetype as the base class. This will run the static initializer function
for the class. The new class object, newclass, will be pushed onto the stack.

When this instruction is executed, the scope stack must contain all the scopes of all base
classes, as the scope stack is saved by the created ClassClosure.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				u1 = U30ARG;
				Traits* ctraits = pool->getClassTraits((uint32_t)u1);
				o1 = (ScriptObject*)(~7 & toplevel->coerce(sp[0], CLASS_TYPE));
				sp[0] = env->newclass(ctraits, (ClassClosure*)o1, scope, scopeBase)->atom();
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$59" string="getdescendants">
			<short>Get descendants.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="3" out_count="1"><![CDATA[ _ , obj, [ns], [name] => _ , value]]><sparam name="obj" class="in"/><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime.

obj is the object to find the descendants in. This will invoke the [[Descendants]] property on
obj with the multiname specified by index. For a description of the [[Descendants]] operator,
see the E4X spec (ECMA-357) sections 9.1.1.8 (for the XML type) and 9.2.1.8 (for the
XMLList type).

Runtime exceptions

A TypeError is thrown if obj is not of type XML or XMLList.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				if (multiname->isRuntime())
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultiname(env, aux_memory->multiname2, sp);
					multiname = &aux_memory->multiname2;
				}
				sp[0] = env->getdescendants(sp[0], multiname);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$5A" string="newcatch">
			<short>Create a new catch scope.</short>
			<params>
				<param name="index" type="u30" class="exceptioninfo"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , catchscope]]><sparam name="catchscope" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index of an exception_info structure for this method.

This instruction creates a new object to serve as the scope object for the catch block for the
exception referenced by index. This new scope is pushed onto the operand stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				u1 = U30ARG;  // catch_index
				t1 = info->abc_exceptions()->exceptions[u1].scopeTraits;
				*(++sp) = env->newcatch(t1)->atom();
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$5B" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$5C" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="III" hex="$5D" string="findpropstrict">
			<short>Find a property.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , [ns], [name] => _ , obj]]><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="obj" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime.
This searches the scope stack, and then the saved scope in the method closure, for a property
with the name specified by the multiname at index.
If any of the objects searched is a with scope, its declared and dynamic properties will be
searched for a match. Otherwise only the declared traits of a scope will be searched. The
global object will have its declared traits, dynamic properties, and prototype chain searched.
If the property is resolved then the object it was resolved in is pushed onto the stack. If the
property is unresolved in all objects on the scope stack then an exception is thrown.

Runtime exceptions

A ReferenceError is thrown if the property is not resolved in any object on the scope stack.

Notes

Functions save the scope stack when they are created, and this saved scope stack is searched if
no match is found in the current scope stack.
Objects for the with statement are pushed onto the scope stack with the pushwith
instruction.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				b1 = true;
				goto findproperty_impl;		
	findproperty_impl:
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				if (multiname->isRuntime())
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultiname(env, aux_memory->multiname2, sp);
					multiname = &aux_memory->multiname2;
				}
				*(++sp) = env->findproperty(scope, scopeBase, scopeDepth, multiname, b1, withBase);
				NEXT; 
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$5E" string="findproperty">
			<short>Search the scope stack for a property.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , [ns], [name] => _ , obj]]><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="obj" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime.
This searches the scope stack, and then the saved scope in the current method closure, for a
property with the name specified by the multiname at index.
If any of the objects searched is a with scope, its declared and dynamic properties will be
searched for a match. Otherwise only the declared traits of a scope will be searched. The
global object will have its declared traits, dynamic properties, and prototype chain searched.
If the property is resolved then the object it was resolved in is pushed onto the stack. If the
property is unresolved in all objects on the scope stack then the global object is pushed onto
the stack.

Notes

Functions save the scope stack when they are created, and this saved scope stack is searched if
no match is found in the current scope stack.
Objects for the with statement are pushed onto the scope stack with the pushwith
instruction.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				b1 = false;
			findproperty_impl:
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				if (multiname->isRuntime())
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultiname(env, aux_memory->multiname2, sp);
					multiname = &aux_memory->multiname2;
				}
				*(++sp) = env->findproperty(scope, scopeBase, scopeDepth, multiname, b1, withBase);
				NEXT; 
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$5F" string="finddef">
			<short>Undocumented</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , [ns], [name] => _ , obj]]><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="obj" class="out"/></stack>
			<description>
				<![CDATA[
Undocumented
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				// methodenv.cpp ScriptObject* MethodEnv::finddef(const Multiname* multiname) const 				
				*(++sp) = env->finddef(multiname)->atom();				
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$60" string="getlex">
			<short>Find and get a property.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , obj]]><sparam name="obj" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the multiname constant pool. The multiname at
index must not be a runtime multiname, so there are never any optional namespace or name
values on the stack.

This is the equivalent of doing a findpropstict followed by a getproperty. It will find the
object on the scope stack that contains the property, and then will get the value from that
object. See "Resolving multinames" on page 10.

Runtime exceptions

A ReferenceError is thrown if the property is unresolved in all of the objects on the scope
stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				// findpropstrict + getproperty
				// stack in:  -
				// stack out: value
				GET_MULTINAME_PTR(multiname, U30ARG);
				// only non-runtime names are allowed.  but this still includes
				// wildcard and attribute names.
				a1 = env->findproperty(scope, scopeBase, scopeDepth, multiname, true, withBase);
				*(++sp) = toplevel->getproperty(a1, multiname, toplevel->toVTable(a1));
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$61" string="setproperty">
			<short>Find and get a property.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , obj]]><sparam name="obj" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the multiname constant pool. The multiname at
index must not be a runtime multiname, so there are never any optional namespace or name
values on the stack.

This is the equivalent of doing a findpropstict followed by a getproperty. It will find the
object on the scope stack that contains the property, and then will get the value from that
object. See "Resolving multinames" on page 10.

Runtime exceptions

A ReferenceError is thrown if the property is unresolved in all of the objects on the scope
stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				a1 = *(sp--);		// value
				if (!multiname->isRuntime())
				{
					a3 = *(sp--);	// object
					toplevel->setproperty(a3, multiname, a1, toplevel->toVTable(a3));
				}
				else if (!multiname->isRtns() && IS_INTEGER(*sp) && *sp >= 0 && AvmCore::isObject(sp[-1]))
				{
					a2 = *(sp--);		// key
					a3 = *(sp--);		// object
					AvmCore::atomToScriptObject(a3)->setUintProperty(UINT32_VALUE(a2), a1);
				}
				else if(multiname->isRtns() || !AvmCore::isDictionaryLookup(*sp, *(sp-1)))
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultiname(env, aux_memory->multiname2, sp);
					a3 = *(sp--);		// object
					toplevel->setproperty(a3, &aux_memory->multiname2, a1, toplevel->toVTable(a3));
				} 
				else 
				{
					a2 = *(sp--);	// key
					a3 = *(sp--);	// object
					AvmCore::atomToScriptObject(a3)->setAtomProperty(a2, a1);
				}
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$62" string="getlocal">
			<short>Get a local register.</short>
			<params>
				<param name="index" type="u30" class="integer"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index of a local register. The value of that register is pushed
onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				u1 = U30ARG;
				*(++sp) = framep[u1];
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$63" string="setlocal">
			<short>Set a local register.</short>
			<params>
				<param name="index" type="u30" class="localregister"/>
			</params>
			<stack in_count="1" out_count="0"><![CDATA[ _ , value => _ ]]><sparam name="value" class="in"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index of a local register. The register at index is set to value,
and value is popped off the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				u1 = U30ARG;
                framep[u1] = *(sp--);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$64" string="getglobalscope">
			<short>Gets the global scope.</short>
			<params>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , obj]]><sparam name="obj" class="out"/></stack>
			<description>
				<![CDATA[
Gets the global scope object from the scope stack, and pushes it onto the stack. The global
scope object is the object at the bottom of the scope stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				AvmAssert(globalScope != NULL);
				*(++sp) = globalScope->atom();
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$65" string="getscopeobject">
			<short>Get a scope object.</short>
			<params>
				<param name="index" type="u30" class="localscope"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , scope]]><sparam name="scope" class="out"/></stack>
			<description>
				<![CDATA[
index is an unsigned byte that specifies the index of the scope object to retrieve from the local
scope stack. index must be less than the current depth of the scope stack. The scope at that
index is retrieved and pushed onto the stack. The scope at the top of the stack is at index
scope_depth-1, and the scope at the bottom of the stack is index 0.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				u1 = U8ARG;  // scope_index
				*(++sp) = scopeBase[(uint32_t)u1];
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$66" string="getproperty">
			<short>Get a property.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="3" out_count="1"><![CDATA[ _ , object, [ns], [name] => _ , value]]><sparam name="object" class="in"/><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime.
The property with the name specified by the multiname will be resolved in object, and the
value of that property will be pushed onto the stack. If the property is unresolved,
undefined is pushed onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				if (!multiname->isRuntime())
				{
					*sp = toplevel->getproperty(*sp, multiname, toplevel->toVTable(*sp));
				}
				else if (!multiname->isRtns() && IS_INTEGER(*sp) && *sp >= 0 && AvmCore::isObject(sp[-1]))
				{
					a2 = *(sp--);	// key
					*sp = AvmCore::atomToScriptObject(*sp)->getUintProperty(UINT32_VALUE(a2));
				}
				else if(multiname->isRtns() || !AvmCore::isDictionaryLookup(*sp, *(sp-1))) 
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultiname(env, aux_memory->multiname2, sp);
					*sp = toplevel->getproperty(*sp, &aux_memory->multiname2, toplevel->toVTable(*sp));
				} 
				else 
				{
					a2 = *(sp--);	// key
					*sp = AvmCore::atomToScriptObject(*sp)->getAtomProperty(a2);
				}
				NEXT; 
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$67" string="getouterscope">
			<short>Undocumented</short>
			<params>
				<param name="index" type="u30" class="scopeindex"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ ... ]]><sparam name=".." class="out"/></stack>
			<description>
				<![CDATA[
index is a U30 which represents the scope index.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                u1 = U30ARG;  // scope_index
				*(++sp) = scope->getScope((uint32_t)u1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$68" string="initproperty">
			<short>Initialize a property.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="4" out_count="0"><![CDATA[ _ , object, [ns], [name], value => _ ]]><sparam name="object" class="in"/><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="value" class="in"/></stack>
			<description>
				<![CDATA[
value is the value that the property will be set to. value is popped off the stack and saved.
index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime.
The property with the name specified by the multiname will be resolved in object, and will be
set to value. This is used to initialize properties in the initializer method. When used in an
initializer method it is able to set the value of const properties.

Runtime exceptions

A TypeError is thrown if object is null or undefined.
A ReferenceError is thrown if the property is not found and object is not dynamic, or if the
instruction is used to set a const property outside an initializer method.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				a1 = *(sp--);		// value
				if (multiname->isRuntime())
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultiname(env, aux_memory->multiname2, sp);
					multiname = &aux_memory->multiname2;
				}
				a2 = *(sp--);	// object
				env->initproperty(a2, multiname, a1, toplevel->toVTable(a2));
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$69" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="III" hex="$6A" string="deleteproperty">
			<short>Delete a property.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="3" out_count="1"><![CDATA[ _ , object, [ns], [name] => _ , value]]><sparam name="object" class="in"/><sparam name="[ns]" class="in"/><sparam name="[name]" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the multiname constant pool. If the multiname at
that index is a runtime multiname the name and/or namespace will also appear on the stack
so that the multiname can be constructed correctly at runtime.
This will invoke the [[Delete]] method on object with the name specified by the multiname.
If object is not dynamic or the property is a fixed property then nothing happens, and false
is pushed onto the stack. If object is dynamic and the property is not a fixed property, it is
removed from object and true is pushed onto the stack.

Runtime exceptions

A ReferenceError is thrown if object is null or undefined.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				if (!multiname->isRuntime())
				{
					sp[0] = env->delproperty(sp[0], multiname);
				}
				else if (!multiname->isRtns() && IS_INTEGER(*sp) && *sp >= 0 && AvmCore::isObject(sp[-1]))
				{
					a2 = *(sp--);	// key
					*sp = AvmCore::atomToScriptObject(*sp)->delUintProperty(UINT32_VALUE(a2)) ? trueAtom : falseAtom;
				}
				else if(multiname->isRtns() || !AvmCore::isDictionaryLookup(*sp, *(sp-1))) 
				{
					aux_memory->multiname2 = *multiname;
					sp = initMultinameNoXMLList(env, aux_memory->multiname2, sp);
					sp[0] = env->delproperty(sp[0], &aux_memory->multiname2);
				} 
				else 
				{
					a2 = *(sp--);	// key
					sp[0] = AvmCore::atomToScriptObject(sp[0])->deleteAtomProperty(a2) ? trueAtom : falseAtom;
				}
				NEXT;  
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$6B" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="III" hex="$6C" string="getslot">
			<short>Get the value of a slot.</short>
			<params>
				<param name="slotindex" type="u30" class="integer"/>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , obj => _ , value]]><sparam name="obj" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
slotindex is a u30 that must be an index of a slot on obj. slotindex must be less than the total
number of slots obj has.
This will retrieve the value stored in the slot at slotindex on obj. This value is pushed onto the
stack.

Runtime exceptions

A TypeError is thrown if obj is null or undefined.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				env->nullcheck(sp[0]);
				// OPTIMIZEME - cleanup after ABC interpreter defenestration.
				// Perform the -1 adjustment in the bytecode translator, not here every time.
				sp[0] = AvmCore::atomToScriptObject(sp[0])->getSlotAtom((uint32_t)U30ARG-1);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$6D" string="setslot">
			<short>Set the value of a slot.</short>
			<params>
				<param name="slotindex" type="u30" class="integer"/>
			</params>
			<stack in_count="2" out_count="0"><![CDATA[ _ , obj, value => _ ]]><sparam name="obj" class="in"/><sparam name="value" class="in"/></stack>
			<description>
				<![CDATA[
slotindex is a u30 that must be an index of a slot on obj. slotindex must be greater than 0 and
less than or equal to the total number of slots obj has.
This will set the value stored in the slot at slotindex on obj to value. value is first coerced to
the type of the slot at slotindex.

Runtime exceptions

A TypeError is thrown if obj is null or undefined.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a1 = sp[-1];
				a2 = sp[0];
				sp -= 2;
				env->nullcheck(a1);
				u1 = U30ARG-1;    // slot_id
				AvmCore::atomToScriptObject(a1)->coerceAndSetSlotAtom((uint32_t)u1, a2);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$6E" string="getglobalslot">
			<short>Get the value of a slot on the global scope.</short>
			<params>
				<param name="slotindex" type="u30" class="integer"/>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
slotindex is a u30 that must be an index of a slot on the global scope. The slotindex must be
greater than 0 and less than or equal to the total number of slots the global scope has.
This will retrieve the value stored in the slot at slotindex of the global scope. This value is
pushed onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				// find the global activation scope (object at depth 0 on scope chain)
				AvmAssert(globalScope != NULL);
				// OPTIMIZMEME - cleanup after ABC interpreter defenestration.
				// Perform the -1 adjustment in the bytecode translator, not here every time.
				sp++;
				sp[0] = globalScope->getSlotAtom((uint32_t)(U30ARG-1));
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$6F" string="setglobalslot">
			<short>Set the value of a slot on the global scope.</short>
			<params>
				<param name="slotindex" type="u30" class="integer"/>
			</params>
			<stack in_count="1" out_count="0"><![CDATA[ _ , value => _ ]]><sparam name="value" class="in"/></stack>
			<description>
				<![CDATA[
slotindex is a u30 that must be an index of a slot on the global scope. The slotindex must be
greater than zero and less than or equal to the total number of slots the global scope has.
This instruction will set the value of the slot at slotindex of the global scope to value. value is
first coerced to the type of the slot indicated by slotindex.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				// find the global activation scope (object at depth 0 on scope chain)
				AvmAssert(globalScope != NULL);

				// OPTIMIZEME - cleanup after ABC interpreter defenestration.
				// Perform the -1 adjustment in the bytecode translator, not here every time.
				u1 = U30ARG-1;    // slot_id
				a1 = sp[0];       // value
				sp--;
				globalScope->coerceAndSetSlotAtom((uint32_t)u1, a1);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$70" string="convert_s">
			<short>Convert a value to a string.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , stringvalue]]><sparam name="value" class="in"/><sparam name="stringvalue" class="out"/></stack>
			<description>
				<![CDATA[
value is popped off of the stack and converted to a string. The result, stringvalue, is pushed
onto the stack. This uses the ToString algorithm, as described in ECMA-262 section 9.8
Notes

This is very similar to the coerce_s opcode. The difference is that coerce_s will not
convert a null or undefined value to the string "null" or "undefined" whereas
convert_s will.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				if ((sp[0] & 7) != kStringType) {
					SAVE_EXPC;
				    sp[0] = core->string(sp[0])->atom();
				}
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$71" string="esc_xelem">
			<short>Escape an xml element.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , stringvalue]]><sparam name="value" class="in"/><sparam name="stringvalue" class="out"/></stack>
			<description>
				<![CDATA[
value is popped off of the stack and converted to a string. The result, stringvalue, is pushed
onto the stack. This uses the ToXmlString algorithm as described in the E4X specification,
ECMA-357 section 10.2, to perform the conversion.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				// ToXMLString will call EscapeElementValue
				SAVE_EXPC;
				sp[0] = core->ToXMLString(sp[0])->atom();
				NEXT; 
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$72" string="esc_xattr">
			<short>Escape an xml attribute.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , stringvalue]]><sparam name="value" class="in"/><sparam name="stringvalue" class="out"/></stack>
			<description>
				<![CDATA[
value is popped off of the stack and converted to a string. The result, stringvalue, is pushed
onto the stack. This uses the EscapeAttributeValue algorithm as described in the E4X
specification, ECMA-357 section 10.2.1.2, to perform the conversion.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				sp[0] = core->EscapeAttributeValue(sp[0])->atom();
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$73" string="convert_i">
			<short>Convert a value to an integer.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , intvalue]]><sparam name="value" class="in"/><sparam name="intvalue" class="out"/></stack>
			<description>
				<![CDATA[
value is popped off of the stack and converted to an integer. The result, intvalue, is pushed
onto the stack. This uses the ToInt32 algorithm, as described in ECMA-262 section 9.5, to
perform the conversion.
]]>
			</description>
			<tamarincode>
				<![CDATA[
 			ABC_CODE_ONLY( convert_i_impl: )
 				a1 = sp[0];
 				if (!IS_INTEGER(a1)) {
 					SAVE_EXPC;
 					sp[0] = core->intAtom(a1);
 				}
				else {
					sp[0] = CLAMP_32(a1);
                }
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$74" string="convert_u">
			<short>Convert a value to an unsigned integer.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , uintvalue]]><sparam name="value" class="in"/><sparam name="uintvalue" class="out"/></stack>
			<description>
				<![CDATA[
value is popped off of the stack and converted to an unsigned integer. The result, uintvalue,
is pushed onto the stack. This uses the ToUint32 algorithm, as described in ECMA-262
section 9.6
]]>
			</description>
			<tamarincode>
				<![CDATA[
			ABC_CODE_ONLY( convert_u_impl: )
				a1 = sp[0];
				if (!IS_INTEGER(a1) || a1 < 0) {
					SAVE_EXPC;
					sp[0] = core->uintAtom(a1);
				}
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$75" string="convert_d">
			<short>Convert a value to a double.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , doublevalue]]><sparam name="value" class="in"/><sparam name="doublevalue" class="out"/></stack>
			<description>
				<![CDATA[
value is popped off of the stack and converted to a double. The result, doublevalue, is pushed
onto the stack. This uses the ToNumber algorithm, as described in ECMA-262 section 9.3,
to perform the conversion.
]]>
			</description>
			<tamarincode>
				<![CDATA[
			ABC_CODE_ONLY( convert_d_impl: )
				if (!IS_DOUBLE(sp[0])) {
					SAVE_EXPC;
					sp[0] = core->numberAtom(sp[0]);
				}
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$76" string="convert_b">
			<short>Convert a value to a Boolean.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , booleanvalue]]><sparam name="value" class="in"/><sparam name="booleanvalue" class="out"/></stack>
			<description>
				<![CDATA[
value is popped off of the stack and converted to a Boolean. The result, booleanvalue, is
pushed onto the stack. This uses the ToBoolean algorithm, as described in ECMA-262
section 9.2, to perform the conversion.
]]>
			</description>
			<tamarincode>
				<![CDATA[
			ABC_CODE_ONLY( convert_b_impl: )
				a1 = sp[0];	// boolean value
				if (IS_BOOLEAN(a1))
					;
				else if (IS_INTEGER(a1))
					sp[0] = a1 == zeroIntAtom ? falseAtom : trueAtom;
				else
					sp[0] = AvmCore::booleanAtom(a1);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$77" string="convert_o">
			<short>Convert a value to an Object.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , value]]><sparam name="value" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
If value is an Object then nothing happens. Otherwise an exception is thrown.
Runtime exceptions
A TypeError is thrown if value is null or undefined.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				if (AvmCore::isNullOrUndefined(sp[0])) {
					SAVE_EXPC;
				    env->nullcheck(sp[0]);
				}
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$78" string="checkfilter">
			<short>Check to make sure an object can have a filter operation performed on it.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , value]]><sparam name="value" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
This instruction checks that the top value of the stack can have a filter operation performed
on it. If value is of type XML or XMLList then nothing happens. If value is of any other type
a TypeError is thrown.

Runtime exceptions

A TypeError is thrown if value is not of type XML or XMLList.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				env->checkfilter(sp[0]);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$79" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$7A" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$7B" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$7C" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$7D" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$7E" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$7F" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="III" hex="$80" string="coerce">
			<short>Coerce a value to a specified type.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , coercedvalue]]><sparam name="value" class="in"/><sparam name="coercedvalue" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the multiname constant pool. The multiname at
index must not be a runtime multiname.

The type specified by the multiname is resolved, and value is coerced to that type. The
resulting value is pushed onto the stack. If any of value's base classes, or implemented
interfaces matches the type specified by the multiname, then the conversion succeeds and the
result is pushed onto the stack.

Runtime exceptions

A TypeError is thrown if value cannot be coerced to the specified type.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
                // expects a CONSTANT_Multiname cpool index
				// this is the ES4 implicit coersion
				GET_MULTINAME_PTR(multiname, U30ARG);
				sp[0] = toplevel->coerce(sp[0], getTraits(multiname, pool, toplevel, core));
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$81" string="convert_b">
			<short>Convert a value to a Boolean.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , booleanvalue]]><sparam name="value" class="in"/><sparam name="booleanvalue" class="out"/></stack>
			<description>
				<![CDATA[
value is popped off of the stack and converted to a Boolean. The result, booleanvalue, is
pushed onto the stack. This uses the ToBoolean algorithm, as described in ECMA-262
section 9.2, to perform the conversion.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				ABC_CODE_ONLY( convert_b_impl: )
				a1 = sp[0];	// boolean value
				if (IS_BOOLEAN(a1))
					;
				else if (IS_INTEGER(a1))
					sp[0] = a1 == zeroIntAtom ? falseAtom : trueAtom;
				else
					sp[0] = AvmCore::booleanAtom(a1);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$82" string="coerce_a">
			<short>Coerce a value to the any type.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , value]]><sparam name="value" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
Indicates to the verifier that the value on the stack is of the any type (*). Does nothing.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				// no-op since interpreter only uses atoms 
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$83" string="convert_i">
			<short>Convert a value to an integer.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , intvalue]]><sparam name="value" class="in"/><sparam name="intvalue" class="out"/></stack>
			<description>
				<![CDATA[
value is popped off of the stack and converted to an integer. The result, intvalue, is pushed
onto the stack. This uses the ToInt32 algorithm, as described in ECMA-262 section 9.5, to
perform the conversion.
]]>
			</description>
			<tamarincode>
				<![CDATA[
ABC_CODE_ONLY( convert_i_impl: )
 				a1 = sp[0];
 				if (!IS_INTEGER(a1)) {
 					SAVE_EXPC;
 					sp[0] = core->intAtom(a1);
 				}
				else {
					sp[0] = CLAMP_32(a1);
                }
				NEXT; 
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$84" string="convert_d">
			<short>Convert a value to a double.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , doublevalue]]><sparam name="value" class="in"/><sparam name="doublevalue" class="out"/></stack>
			<description>
				<![CDATA[
value is popped off of the stack and converted to a double. The result, doublevalue, is pushed
onto the stack. This uses the ToNumber algorithm, as described in ECMA-262 section 9.3,
to perform the conversion.
]]>
			</description>
			<tamarincode>
				<![CDATA[

			ABC_CODE_ONLY( convert_d_impl: )
				if (!IS_DOUBLE(sp[0])) {
					SAVE_EXPC;
					sp[0] = core->numberAtom(sp[0]);
				}
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$85" string="coerce_s">
			<short>Coerce a value to the any type.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , value]]><sparam name="value" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
value is popped off of the stack and coerced to a String. If value is null or undefined, then
stringvalue is set to null. Otherwise stringvalue is set to the result of the ToString algorithm,
as specified in ECMA-262 section 9.8. stringvalue is pushed onto the stack.

Notes

This opcode is very similar to the convert_s opcode. The difference is that convert_s will
convert a null or undefined value to the string "null" or "undefined" whereas coerce_s
will convert those values to the null value.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[0];
				if (!IS_STRING(a1)) {
					SAVE_EXPC;
					sp[0] = AvmCore::isNullOrUndefined(a1) ? nullStringAtom : core->string(a1)->atom();
				}
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$86" string="astype">
			<short>Return the same value, or null if not of the specified type.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , value]]><sparam name="value" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the multiname constant pool. The multiname at
index must not be a runtime multiname, and must be the name of a type.

Pop value off of the stack. If value is of the type specified by the multiname, push value back
onto the stack. If value is not of the type specified by the multiname, then push null onto
the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				GET_MULTINAME_PTR(multiname, U30ARG);
				sp[0] = AvmCore::astype(sp[0], getTraits(multiname, pool, toplevel, core));
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$87" string="astypelate">
			<short>Return the same value, or null if not of the specified type.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value, class => _ , value]]><sparam name="value" class="in"/><sparam name="class" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
Pop class and value off of the stack. class should be an object of type Class. If value is of the
type specified by class, push value back onto the stack. If value is not of the type specified by
class, then push null onto the stack.

Runtime exceptions

A TypeError is thrown if class is not of type Class.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
				sp[0] = AvmCore::astype(a1, toplevel->toClassITraits(a2));
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$88" string="convert_u">
			<short>Convert a value to an unsigned integer.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , uintvalue]]><sparam name="value" class="in"/><sparam name="uintvalue" class="out"/></stack>
			<description>
				<![CDATA[
value is popped off of the stack and converted to an unsigned integer. The result, uintvalue,
is pushed onto the stack. This uses the ToUint32 algorithm, as described in ECMA-262
section 9.6
]]>
			</description>
			<tamarincode>
				<![CDATA[
			ABC_CODE_ONLY( convert_u_impl: )
				a1 = sp[0];
				if (!IS_INTEGER(a1) || a1 < 0) {
					SAVE_EXPC;
					sp[0] = core->uintAtom(a1);
				}
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$89" string="coerce_o">
			<short>Convert value to null if its undefined. (Undocumented) </short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , value]]><sparam name="value" class="in"/><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
Indicates to the verifier that the value on the stack is of the any type (*). Does nothing.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				if (sp[0] == undefinedAtom)
					sp[0] = nullObjectAtom;
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$8A" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$8B" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$8C" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$8D" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$8E" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$8F" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="III" hex="$90" string="negate">
			<short>Negate a value. </short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , -value]]><sparam name="value" class="in"/><sparam name="-value" class="out"/></stack>
			<description>
				<![CDATA[
Pop value off of the stack. Convert value to a Number using the ToNumber algorithm
(ECMA-262 section 9.3) and then negate the Number value. Push the result onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[0];
				if (IS_INTEGER(a1) && a1 != zeroIntAtom) {
					i1 = -atomGetIntptr(a1); // *not* INT32_VALUE
                    if (atomIsValidIntptrValue(i1)) {
                        sp[0] = MAKE_INTEGER(i1);
                        NEXT;
                    }
				}
				SAVE_EXPC;
				sp[0] = core->doubleToAtom(-AvmCore::number(a1));
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$91" string="increment">
			<short>Increment a value.</short>
			<params>
			</params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[
Pop value off of the stack. Convert value to a Number using the ToNumber algorithm
(ECMA-262 section 9.3) and then add 1 to the Number value. Push the result onto the
stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a2p = sp;
			increment_impl:
				a1 = *a2p;
				FAST_INC_MAYBE(a1,*a2p);	// note, *a2p is lvalue here
				*a2p = core->numberAtom(a1);
				core->increment_d(a2p, 1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$92" string="inclocal">
			<short>Increment a local register value.</short>
			<params>
				<param name="index" type="u30" class="localregister"/>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , name, obj => _ , result]]><sparam name="name" class="in"/><sparam name="obj" class="in"/><sparam name="result" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index of a local register. The value of the local register at index
is converted to a Number using the ToNumber algorithm (ECMA-262 section 9.3) and
then 1 is added to the Number value. The local register at index is then set to the result.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a2p = framep+U30ARG;
				goto increment_impl;
				...
			increment_impl:
				a1 = *a2p;
				FAST_INC_MAYBE(a1,*a2p);	// note, *a2p is lvalue here
				*a2p = core->numberAtom(a1);
				core->increment_d(a2p, 1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$93" string="decrement">
			<short>Decrement a value.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , decrementedvalue]]><sparam name="value" class="in"/><sparam name="decrementedvalue" class="out"/></stack>
			<description>
				<![CDATA[
Pop value off of the stack. Convert value to a Number using the ToNumber algorithm
(ECMA-262 section 9.3) and then subtract 1 from the Number value. Push the result onto
the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a2p = sp;
			increment_impl:
				a1 = *a2p;
				FAST_INC_MAYBE(a1,*a2p);	// note, *a2p is lvalue here
				*a2p = core->numberAtom(a1);
				core->increment_d(a2p, 1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$94" string="declocal">
			<short>Decrement a local register value.</short>
			<params>
				<param name="index" type="u30" class="localregister"/>
			</params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[

index is a u30 that must be an index of a local register. The value of the local register at index
is converted to a Number using the ToNumber algorithm (ECMA-262 section 9.3) and
then 1 is subtracted from the Number value. The local register at index is then set to the
result.

]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a2p = framep+U30ARG;
				goto decrement_impl;
				...
decrement_impl:
				a1 = *a2p;
				FAST_DEC_MAYBE(a1,*a2p);	// note, *a2p is lvalue here
				*a2p = core->numberAtom(a1);
				core->increment_d(a2p, -1);
                NEXT;
			
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$95" string="typeof">
			<short>Get the type name of a value.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , typename]]><sparam name="value" class="in"/><sparam name="typename" class="out"/></stack>
			<description>
				<![CDATA[

Pop a value off of the stack. 
Determine its type name according to the type of value:

1. undefined = "undefined"
2. null = "object"
3. Boolean = "Boolean"
4. Number | int | uint = "number"
5. String = "string"
6. Function = "function"
7. XML | XMLList = "xml"
8. Object = "object"
Push typename onto the stack.

]]>
			</description>
			<tamarincode>
				<![CDATA[
				*sp = core->_typeof(*sp)->atom();
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$96" string="not">
			<short>Boolean negation.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , !value]]><sparam name="value" class="in"/><sparam name="!value" class="out"/></stack>
			<description>
				<![CDATA[
Pop value off of the stack. Convert value to a Boolean using the ToBoolean algorithm
(ECMA-262 section 9.2) and then negate the Boolean value. Push the result onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[0];		// boolean value
				if (IS_BOOLEAN(a1))
					;
				else if (IS_INTEGER(a1))
					a1 = a1 == zeroIntAtom ? falseAtom : trueAtom;
				else
					a1 = AvmCore::booleanAtom(a1);
                sp[0] = a1 ^ (trueAtom ^ falseAtom);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$97" string="bitnot">
			<short>Bitwise not.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , !value]]><sparam name="value" class="in"/><sparam name="!value" class="out"/></stack>
			<description>
				<![CDATA[
Pop value off of the stack. Convert value to an integer, as per ECMA-262 section 11.4.8,
and then apply the bitwise complement operator (~) to the integer. Push the result onto the
stack.]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[0];
				if (IS_INTEGER(a1)) {
					sp[0] = MAKE_INTEGER(~int32_t(atomGetIntptr(a1)));
					NEXT;
				}
				SAVE_EXPC;
				*sp = core->intToAtom(~AvmCore::integer(a1));
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$98" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$99" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$9A" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$9B" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$9C" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$9D" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$9E" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="UNU" hex="$9F" string="Unused">
			<stack in_count="0" out_count="0"></stack></opcode>
		<opcode type="III" hex="$A0" string="add">
			<short>Add two values.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack and add them together as specified in ECMA-262 section
11.6 and as extended in ECMA-357 section 11.4. The algorithm is briefly described below.

1. If value1 and value2 are both Numbers, then set value3 to the result of adding the two
number values. See ECMA-262 section 11.6.3 for a description of adding number values.

2. If value1 or value2 is a String or a Date, convert both values to String using the ToString
algorithm described in ECMA-262 section 9.8. Concatenate the string value of value2 to the
string value of value1 and set value3 to the new concatenated String.

3. If value1 and value2 are both of type XML or XMLList, construct a new XMLList object,
then call [[Append]](value1), and then [[Append]](value2). Set value3 to the new XMLList.
See ECMA-357 section 9.2.1.6 for a description of the [[Append]] method.

4. If none of the above apply, convert value1 and value2 to primitives. This is done by calling
ToPrimitive with no hint. This results in value1_primitive and value2_primitive. If
value1_primitive or value2_primitive is a String then convert both to Strings using the
ToString algorithm (ECMA-262 section 9.8), concatenate the results, and set value3 to the
concatenated String. Otherwise convert both to Numbers using the ToNumber algorithm
(ECMA-262 section 9.3), add the results, and set value3 to the result of the addition.
Push value3 onto the stack.

Notes

For more information, see ECMA-262 section 11.6 ("Additive Operators") and ECMA-357
section 11.4.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
			PEEPHOLE_ONLY( add_two_values_into_tos_impl: )
				ADD_TWO_VALUES_AND_NEXT(a1, a2, sp[0]);
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$A1" string="subtract">
			<short>Subtract one value from another.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack and add them together as specified in ECMA-262 section
11.6 and as extended in ECMA-357 section 11.4. The algorithm is briefly described below.

1. If value1 and value2 are both Numbers, then set value3 to the result of adding the two
number values. See ECMA-262 section 11.6.3 for a description of adding number values.

2. If value1 or value2 is a String or a Date, convert both values to String using the ToString
algorithm described in ECMA-262 section 9.8. Concatenate the string value of value2 to the
string value of value1 and set value3 to the new concatenated String.

3. If value1 and value2 are both of type XML or XMLList, construct a new XMLList object,
then call [[Append]](value1), and then [[Append]](value2). Set value3 to the new XMLList.
See ECMA-357 section 9.2.1.6 for a description of the [[Append]] method.

4. If none of the above apply, convert value1 and value2 to primitives. This is done by calling
ToPrimitive with no hint. This results in value1_primitive and value2_primitive. If
value1_primitive or value2_primitive is a String then convert both to Strings using the
ToString algorithm (ECMA-262 section 9.8), concatenate the results, and set value3 to the
concatenated String. Otherwise convert both to Numbers using the ToNumber algorithm
(ECMA-262 section 9.3), add the results, and set value3 to the result of the addition.
Push value3 onto the stack.

Notes

For more information, see ECMA-262 section 11.6 ("Additive Operators") and ECMA-357
section 11.4.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[-1];
				a2 = sp[0];
				sp--;

				if (IS_BOTH_INTEGER(a1, a2)) { 
					u1t = a1 ^ kIntptrType; 
					u2t = a2 ^ kIntptrType;
					u3t = SIGN_EXTEND(u1t - u2t); 
					if ((intptr_t)(u1t ^ u2t) >= 0 || (intptr_t)(u1t ^ u3t) >= 0) { 
						sp[0] = CHECK_INT_ATOM(u3t | kIntptrType); 
						NEXT; 
					} 
				} 
				if (IS_BOTH_DOUBLE(a1, a2)) { 
					sp[0] = core->doubleToAtom(DOUBLE_VALUE(a1) - DOUBLE_VALUE(a2)); 
					NEXT; 
				}
				SAVE_EXPC;
				d1 = AvmCore::number(a1);
				d2 = AvmCore::number(a2);
				sp[0] = core->doubleToAtom(d1 - d2);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$A2" string="multiply">
			<short>Multiply two values.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack, convert value1 and value2 to Number to create
value1_number and value2_number. Multiply value1_number by value2_number and push
the result onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
#ifdef AVMPLUS_PEEPHOLE_OPTIMIZER
			mul_two_values_and_next:
#endif
				// OPTIMIZEME - multiplication of small integers might be optimized?
				if (IS_BOTH_DOUBLE(a1, a2)) {
					sp[0] = core->doubleToAtom(DOUBLE_VALUE(a1) * DOUBLE_VALUE(a2)); \
					NEXT;
				}
				SAVE_EXPC;
				d1 = AvmCore::number(a1);
				d2 = AvmCore::number(a2);
				sp[0] = core->doubleToAtom(d1 * d2);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$A3" string="divide">
			<short>Divide two values.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack, convert value1 and value2 to Number to create
value1_number and value2_number. Divide value1_number by value2_number and push the
result onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				// OPTIMIZEME - division of small integers might be optimized?
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
				
				if (IS_BOTH_DOUBLE(a1, a2)) {
					sp[0] = core->doubleToAtom(DOUBLE_VALUE(a1) / DOUBLE_VALUE(a2));
					NEXT;
				}
				SAVE_EXPC;
				d1 = AvmCore::number(a1);
				d2 = AvmCore::number(a2);
				sp[0] = core->doubleToAtom(d1 / d2);
				NEXT;

]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$A4" string="modulo">
			<short>Perform modulo division on two values.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack, convert value1 and value2 to Number to create
value1_number and value2_number. Perform value1_number mod value2_number and push
the result onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				// FIXME - dodgy optimization?
				// Can the integer modulo overflow somehow?  Is it portable?
				a1 = sp[-1];
				a2 = sp[0];
				sp--;

				if (IS_BOTH_INTEGER(a1, a2) && a2 != zeroIntAtom) {
					i1 = INT32_VALUE(a1) % INT32_VALUE(a2);
					if (atomIsValidIntptrValue(i1)) {
						sp[0] = MAKE_INTEGER(i1);
						NEXT;
					}
				}
				else if (IS_BOTH_DOUBLE(a1, a2)) {
					sp[0] = core->doubleToAtom(MathUtils::mod(DOUBLE_VALUE(a1), DOUBLE_VALUE(a2)));
					NEXT;
				}
				SAVE_EXPC;
				d1 = AvmCore::number(a1);
				d2 = AvmCore::number(a2);
				sp[0] = core->doubleToAtom(MathUtils::mod(d1, d2));
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$A5" string="lshift">
			<short>Bitwise left shift.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack; convert value1 to an int to create value1_int ; and
convert value2 to a uint to create value2_uint. Left shift value1_int by the result of
value2_uint & 0x1F (leaving only the 5 least significant bits of value2_uint), and push the
result onto the stack. See ECMA-262 section 11.7.1.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
			//lshift_two_values_and_next:
				if (IS_BOTH_INTEGER(a1,a2)) {
					i1 = INT32_VALUE(a1) << (INT32_VALUE(a2) & 0x1F);
					if (atomIsValidIntptrValue(i1)) {
						sp[0] = SIGN_EXTEND(MAKE_INTEGER(i1));
						NEXT;
					}
				}
				SAVE_EXPC;
				i1 = AvmCore::integer(a1);
				u2 = AvmCore::toUInt32(a2);
				sp[0] = core->intToAtom( (int32_t)(i1 << (u2 & 0x1F)) );
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$A6" string="rshift">
			<short>Signed bitwise right shift.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack, convert value1 to an int to create value1_int and
convert value2 to a uint to create value2_uint. Right shift value1_int by the result of
value2_uint & 0x1F (leaving only the 5 least significant bits of value2_uint), and push the
result onto the stack. The right shift is sign extended, resulting in a signed 32-bit integer. See
ECMA-262 section 11.7.2
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
			//rshift_two_values_and_next:
				if (IS_BOTH_INTEGER(a1,a2)) {
					sp[0] = MAKE_INTEGER(INT32_VALUE(a1) >> (INT32_VALUE(a2) & 0x1F));
					NEXT;
				}
				SAVE_EXPC;
				i1 = AvmCore::integer(a1);
				u2 = AvmCore::toUInt32(a2);
				sp[0] = core->intToAtom( (int32_t)(i1 >> (u2 & 0x1F)) );
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$A7" string="urshift">
			<short>Unsigned bitwise right shift.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack, convert value1 to an int to create value1_int and
convert value2 to a uint to create value2_uint. Right shift value1_int by the result of
value2_uint & 0x1F (leaving only the 5 least significant bits of value2_uint), and push the
result onto the stack. The right shift is unsigned and fills in missing bits with 0, resulting in
an unsigned 32-bit integer. See ECMA-262 section 11.7.3
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
			//urshift_two_values_and_next:
				if (IS_BOTH_INTEGER(a1,a2)) {
                    u1 = (UINT32_VALUE(a1) >> (INT32_VALUE(a2) & 0x1F));
					if (atomIsValidIntptrValue_u(u1)) {
						sp[0] = MAKE_INTEGER(u1);
						NEXT;
					}
				}
				SAVE_EXPC;
				u1 = AvmCore::toUInt32(a1);
				u2 = AvmCore::toUInt32(a2);
				sp[0] = core->uintToAtom( (uint32_t)(u1 >> (u2 & 0x1F)) );
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$A8" string="bitand">
			<short>Bitwise and.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack. Convert value1 and value2 to integers, as per ECMA-
262 section 11.10, and perform a bitwise and (&) on the two resulting integer values. Push
the result onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
				BITOP_TWO_VALUES_AND_NEXT(&, a1, a2, sp[0], 0);
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$A9" string="bitor">
			<short>Bitwise or.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack. Convert value1 and value2 to integers, as per ECMA-
262 section 11.10, and perform a bitwise or (|) on the two resulting integer values. Push the
result onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
a1 = sp[-1];
				a2 = sp[0];
				sp--;
				BITOP_TWO_VALUES_AND_NEXT(|, a1, a2, sp[0], 0);
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$AA" string="bitxor">
			<short>Bitwise exclusive or.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack. Convert value1 and value2 to integers, as per ECMA-
262 section 11.10, and perform a bitwise exclusive or (^) on the two resulting integer values.
Push the result onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
a1 = sp[-1];
				a2 = sp[0];
				sp--;
				BITOP_TWO_VALUES_AND_NEXT(^, a1, a2, sp[0], kIntptrType);
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$AB" string="equals">
			<short>Compare two values.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack. Compare the two values using the abstract equality
comparison algorithm, as described in ECMA-262 section 11.9.3 and extended in ECMA-
347 section 11.5.1. Push the resulting Boolean value onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				// OPTIMIZEME - equals on some classes of values?
				SAVE_EXPC;
				sp[-1] = core->equals(sp[-1], sp[0]);
                sp--;
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$AC" string="strictequals">
			<short>Compare two values strictly.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack. Compare the two values using the Strict Equality
Comparison Algorithm as described in ECMA-262 section 11.9.6. Push the resulting
Boolean value onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				// OPTIMIZEME - strictequals on some classes of values?
                sp[-1] = core->stricteq(sp[-1], sp[0]);
                sp--;
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$AD" string="lessthan">
			<short>Compare two values strictly.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , result]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="result" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack. Compare the two values using the Strict Equality
Comparison Algorithm as described in ECMA-262 section 11.9.6. Push the resulting
Boolean value onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[

#define CMP2(numeric_cmp, generic_cmp) \
	a1 = sp[-1]; \
    a2 = sp[0]; \
	sp--; \
	if (IS_BOTH_INTEGER(a1, a2))								\
		b1 = a1 numeric_cmp a2; \
	else if (IS_BOTH_DOUBLE(a1, a2)) \
		b1 = DOUBLE_VALUE(a1) numeric_cmp DOUBLE_VALUE(a2); \
	else { \
		SAVE_EXPC; \
		b1 = generic_cmp; \
	} \
    sp[0] = b1 ? trueAtom : falseAtom;

	...
	
            INSTR(lessthan) {
				CMP2(<, core->compare(a1,a2) == trueAtom);
                NEXT;
			}
			
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$AE" string="lessequals">
			<short>Determine if one value is less than or equal to another.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , result]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="result" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack. Compute value2 < value1 using the Abstract
Relational Comparison Algorithm as described in ECMA-262 section 11.8.5. If the result of
the comparison is false, push true onto the stack. Otherwise push false onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[

#define CMP2(numeric_cmp, generic_cmp) \
	a1 = sp[-1]; \
    a2 = sp[0]; \
	sp--; \
	if (IS_BOTH_INTEGER(a1, a2))								\
		b1 = a1 numeric_cmp a2; \
	else if (IS_BOTH_DOUBLE(a1, a2)) \
		b1 = DOUBLE_VALUE(a1) numeric_cmp DOUBLE_VALUE(a2); \
	else { \
		SAVE_EXPC; \
		b1 = generic_cmp; \
	} \
    sp[0] = b1 ? trueAtom : falseAtom;

	...
            INSTR(lessequals) {
				CMP2(<=, core->compare(a2, a1) == falseAtom);
                NEXT;
			}
			
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$AF" string="greaterthan">
			<short>Determine if one value is greater than another.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , result]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="result" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack. Compute value2 < value1 using the Abstract
Relational Comparison Algorithm as described in ECMA-262 section 11.8.5. If the result of
the comparison is true, push true onto the stack. Otherwise push false onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[

#define CMP2(numeric_cmp, generic_cmp) \
	a1 = sp[-1]; \
    a2 = sp[0]; \
	sp--; \
	if (IS_BOTH_INTEGER(a1, a2))								\
		b1 = a1 numeric_cmp a2; \
	else if (IS_BOTH_DOUBLE(a1, a2)) \
		b1 = DOUBLE_VALUE(a1) numeric_cmp DOUBLE_VALUE(a2); \
	else { \
		SAVE_EXPC; \
		b1 = generic_cmp; \
	} \
    sp[0] = b1 ? trueAtom : falseAtom;

	...
            INSTR(greaterthan) {
				CMP2(>, core->compare(a2, a1) == trueAtom);
                NEXT;
			}
			
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$B0" string="greaterequals">
			<short>Determine if one value is greater than or equal to another.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , result]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="result" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack. Compute value2 <= value1 using the Abstract
Relational Comparison Algorithm as described in ECMA-262 section 11.8.5. If the result of
the comparison is false, push true onto the stack. Otherwise push false onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[

#define CMP2(numeric_cmp, generic_cmp) \
	a1 = sp[-1]; \
    a2 = sp[0]; \
	sp--; \
	if (IS_BOTH_INTEGER(a1, a2))								\
		b1 = a1 numeric_cmp a2; \
	else if (IS_BOTH_DOUBLE(a1, a2)) \
		b1 = DOUBLE_VALUE(a1) numeric_cmp DOUBLE_VALUE(a2); \
	else { \
		SAVE_EXPC; \
		b1 = generic_cmp; \
	} \
    sp[0] = b1 ? trueAtom : falseAtom;

	...
            INSTR(greaterthan) {
				CMP2(>, core->compare(a2, a1) == trueAtom);
                NEXT;
			}
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$B1" string="instanceof">
			<short>Check the prototype chain of an object for the existence of a type.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value, type => _ , result]]><sparam name="value" class="in"/><sparam name="type" class="in"/><sparam name="result" class="out"/></stack>
			<description>
				<![CDATA[
Pop value and type off of the stack. If value is null result is false. Walk up the prototype
chain of value looking for type. If type is present anywhere on the prototype, result is true. If
type is not found on the prototype chain, result is false. Push result onto the stack. See
ECMA-262 section 11.8.6 for a further description.

Runtime exceptions

A TypeError is thrown if type is not an Object.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
				sp[0] = toplevel->instanceof(a1, a2);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$B2" string="istype">
			<short>Check whether an Object is of a certain type.</short>
			<params>
				<param name="index" type="u30" class="multiname"/>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , result]]><sparam name="value" class="in"/><sparam name="result" class="out"/></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the multiname constant pool. The multiname at
index must not be a runtime multiname.

Resolve the type specified by the multiname. Let indexType refer to that type. Compute the
type of value, and let valueType refer to that type. If valueType is the same as indexType, result
is true. If indexType is a base type of valueType, or an implemented interface of valueType,
then result is true. Otherwise result is set to false. Push result onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
                // expects a CONSTANT_Multiname cpool index
				// used when operator "is" RHS is a compile-time type constant
				GET_MULTINAME_PTR(multiname, U30ARG);
				t1 = getTraits(multiname, pool, toplevel, core);	// itraits
				sp[0] = AvmCore::istypeAtom(sp[0], t1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$B3" string="istypelate">
			<short>Check whether an Object is of a certain type.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , result]]><sparam name="value" class="in"/><sparam name="result" class="out"/></stack>
			<description>
				<![CDATA[
Compute the type of value, and let valueType refer to that type. If valueType is the same as
type, result is true. If type is a base type of valueType, or an implemented interface of
valueType, then result is true. Otherwise result is set to false. Push result onto the stack.

Runtime exceptions

A TypeError is thrown if type is not a Class.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
				sp[0] = AvmCore::istypeAtom(a1, toplevel->toClassITraits(a2));
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$B4" string="in">
			<short>Check whether an Object is of a certain type.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , name, obj => _ , result]]><sparam name="name" class="in"/><sparam name="obj" class="in"/><sparam name="result" class="out"/></stack>
			<description>
				<![CDATA[
Compute the type of value, and let valueType refer to that type. If valueType is the same as
type, result is true. If type is a base type of valueType, or an implemented interface of
valueType, then result is true. Otherwise result is set to false. Push result onto the stack.

Runtime exceptions

A TypeError is thrown if type is not a Class.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
				sp[0] = AvmCore::istypeAtom(a1, toplevel->toClassITraits(a2));
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$B5" string="">
		</opcode>
		<opcode type="UNU" hex="$B6" string="">
		</opcode>
		<opcode type="UNU" hex="$B7" string="">
		</opcode>
		<opcode type="UNU" hex="$B8" string="">
		</opcode>
		<opcode type="UNU" hex="$B9" string="">
		</opcode>
		<opcode type="UNU" hex="$BA" string="">
		</opcode>
		<opcode type="UNU" hex="$BB" string="">
		</opcode>
		<opcode type="UNU" hex="$BC" string="">
		</opcode>
		<opcode type="UNU" hex="$BD" string="">
		</opcode>
		<opcode type="UNU" hex="$BE" string="">
		</opcode>
		<opcode type="UNU" hex="$BF" string="">
		</opcode>
		<opcode type="III" hex="$C0" string="increment_i">
			<short>Increment an integer value.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , incrementedvalue]]><sparam name="value" class="in"/><sparam name="incrementedvalue" class="out"/></stack>
			<description>
				<![CDATA[
Pop value off of the stack. Convert value to an int using the ToInt32 algorithm (ECMA-262
section 9.5) and then add 1 to the int value. Push the result onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a2p = sp;
			increment_i_impl:
				a1 = *a2p;
 				if (!IS_INTEGER(a1)) {
 					a1 = core->intAtom(a1);
 				}
				FAST_INC_MAYBE(a1,*a2p);	// note, *a2p is lvalue here
				core->increment_i(a2p, 1);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$C1" string="decrement_i">
			<short>Decrement an integer value.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , decrementedvalue]]><sparam name="value" class="in"/><sparam name="decrementedvalue" class="out"/></stack>
			<description>
				<![CDATA[
Pop value off of the stack. Convert value to an int using the ToInt32 algorithm (ECMA-262
section 9.5) and then subtract 1 from the int value. Push the result onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a2p = sp;
			decrement_i_impl:
				a1 = *a2p;
				FAST_DEC_MAYBE(a1,*a2p);	// note, *a2p is lvalue here
				core->increment_i(a2p, -1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$C2" string="inclocal_i">
			<short>Increment a local register value.</short>
			<params>
				<param name="index" type="u30" class="localregister"/>
			</params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index of a local register. The value of the local register at index
is converted to an int using the ToInt32 algorithm (ECMA-262 section 9.5) and then 1 is
added to the int value. The local register at index is then set to the result.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a2p = framep+U30ARG;
				goto increment_i_impl;
				
				increment_i_impl:
				a1 = *a2p;
 				if (!IS_INTEGER(a1)) {
 					a1 = core->intAtom(a1);
 				}
				FAST_INC_MAYBE(a1,*a2p);	// note, *a2p is lvalue here
				core->increment_i(a2p, 1);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$C3" string="declocal_i">
			<short>Decrement a local register value.</short>
			<params>
				<param name="index" type="u30" class="localregister"/>
			</params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index of a local register. The value of the local register at index
is converted to an int using the ToInt32 algorithm (ECMA-262 section 9.5) and then 1 is
subtracted the int value. The local register at index is then set to the result.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				a2p = framep+U30ARG;
				goto decrement_i_impl;
				
				decrement_i_impl:
				a1 = *a2p;
				FAST_DEC_MAYBE(a1,*a2p);	// note, *a2p is lvalue here
				core->increment_i(a2p, -1);
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$C4" string="negate_i">
			<short>Negate an integer value.</short>
			<params>
			</params>
			<stack in_count="1" out_count="1"><![CDATA[ _ , value => _ , -value]]><sparam name="value" class="in"/><sparam name="-value" class="out"/></stack>
			<description>
				<![CDATA[
Pop value off of the stack. Convert value to an int using the ToInt32 algorithm (ECMA-262
section 9.5) and then negate the int value. Push the result onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				// OPTIMIZEME - negate_i
				SAVE_EXPC;
                sp[0] = core->intToAtom(-AvmCore::integer(sp[0]));
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$C5" string="add_i">
			<short>Add two integer values.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack and convert them to int values using the ToInt32
algorithm (ECMA-262 section 9.5). Add the two int values and push the result onto the
stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
				if (IS_BOTH_INTEGER(a1, a2)) {
					u1t = a1 ^ kIntptrType;
					u2t = a2 ^ kIntptrType;
					u3t = CLAMP_32(u1t + u2t);
					sp[0] = CHECK_INT_ATOM(u3t | kIntptrType);
					NEXT;
				}
				if (IS_BOTH_DOUBLE(a1, a2)) { 
					i1 = (int32_t)AvmCore::integer_d(DOUBLE_VALUE(a1));
					i2 = (int32_t)AvmCore::integer_d(DOUBLE_VALUE(a2));
					goto finish_add_i;
				}
				SAVE_EXPC;
				i1 = AvmCore::integer(a1);
				i2 = AvmCore::integer(a2);
			finish_add_i:
				sp[0] = core->intToAtom((int32_t)(i1 + i2));
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$C6" string="subtract_i">
			<short>Subtract an integer value from another integer value.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack and convert value1 and value2 to int to create
value1_int and value2_int. Subtract value2_int from value1_int. Push the result onto the
stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
				if (IS_BOTH_INTEGER(a1, a2)) {
					u1t = a1 ^ kIntptrType;
					u2t = a2 ^ kIntptrType;
					u3t = CLAMP_32(u1t - u2t);
					sp[0] = CHECK_INT_ATOM(u3t | kIntptrType);
					NEXT;
				}
				if (IS_BOTH_DOUBLE(a1, a2)) { 
					i1 = (int32_t)AvmCore::integer_d(DOUBLE_VALUE(a1));
					i2 = (int32_t)AvmCore::integer_d(DOUBLE_VALUE(a2));
					goto finish_subtract_i;
				}
				SAVE_EXPC;
				i1 = AvmCore::integer(a1);
				i2 = AvmCore::integer(a2);
			finish_subtract_i:
				sp[0] = core->intToAtom((int32_t)(i1 - i2));
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="III" hex="$C7" string="multiply_i">
			<short>Multiply two integer values.</short>
			<params>
			</params>
			<stack in_count="2" out_count="1"><![CDATA[ _ , value1, value2 => _ , value3]]><sparam name="value1" class="in"/><sparam name="value2" class="in"/><sparam name="value3" class="out"/></stack>
			<description>
				<![CDATA[
Pop value1 and value2 off of the stack, convert value1 and value2 to int to create value1_int
and value2_int. Multiply value1_int by value2_int and push the result onto the stack.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				// OPTIMIZEME - multiplication of small integers might be optimized?
				SAVE_EXPC;
				a1 = sp[-1];
				a2 = sp[0];
				sp--;
				i1 = AvmCore::integer(a1);
				i2 = AvmCore::integer(a2);
                sp[0] = core->intToAtom((int32_t)(i1 * i2));
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$C8" string="">
		</opcode>
		<opcode type="UNU" hex="$C9" string="">
		</opcode>
		<opcode type="UNU" hex="$CA" string="">
		</opcode>
		<opcode type="UNU" hex="$CB" string="">
		</opcode>
		<opcode type="UNU" hex="$CC" string="">
		</opcode>
		<opcode type="UNU" hex="$CD" string="">
		</opcode>
		<opcode type="UNU" hex="$CE" string="">
		</opcode>
		<opcode type="UNU" hex="$CF" string="">
		</opcode>
		<opcode type="IIU" hex="$D0" string="getlocal0">
			<short>Get a local register 0.</short>
			<params>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
Undocumented.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                *(++sp) = framep[0];
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$D1" string="getlocal1">
			<short>Get local register 1.</short>
			<params>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
Undocumented.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                *(++sp) = framep[1];
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$D2" string="getlocal2">
			<short>Get local register 2.</short>
			<params>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
Undocumented.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                *(++sp) = framep[2];
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$D3" string="getlocal3">
			<short>Get local register 3.</short>
			<params>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
Undocumented.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                *(++sp) = framep[3];
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$D4" string="setlocal0">
			<short>Get local register 0.</short>
			<params>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
Undocumented.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                *(++sp) = framep[0];
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$D5" string="setlocal1">
			<short>Set local register 0.</short>
			<params>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
Undocumented.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                framep[0] = *(sp--);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$D6" string="setlocal2">
			<short>Set local register 2.</short>
			<params>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
Undocumented.
]]>
			</description>
			<tamarincode>
				<![CDATA[
<![CDATA[
                framep[2] = *(sp--);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IIU" hex="$D7" string="setlocal3">
			<short>Set local register 3.</short>
			<params>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
Undocumented.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                framep[3] = *(sp--);
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$D8" string="">
		</opcode>
		<opcode type="UNU" hex="$D9" string="">
		</opcode>
		<opcode type="UNU" hex="$DA" string="">
		</opcode>
		<opcode type="UNU" hex="$DB" string="">
		</opcode>
		<opcode type="UNU" hex="$DC" string="">
		</opcode>
		<opcode type="UNU" hex="$DD" string="">
		</opcode>
		<opcode type="UNU" hex="$DE" string="">
		</opcode>
		<opcode type="UNU" hex="$DF" string="">
		</opcode>
		<opcode type="UNU" hex="$E0" string="">
		</opcode>
		<opcode type="UNU" hex="$E1" string="">
		</opcode>
		<opcode type="UNU" hex="$E2" string="">
		</opcode>
		<opcode type="UNU" hex="$E3" string="">
		</opcode>
		<opcode type="UNU" hex="$E4" string="">
		</opcode>
		<opcode type="UNU" hex="$E5" string="">
		</opcode>
		<opcode type="UNU" hex="$E6" string="">
		</opcode>
		<opcode type="UNU" hex="$E7" string="">
		</opcode>
		<opcode type="UNU" hex="$E8" string="">
		</opcode>
		<opcode type="UNU" hex="$E9" string="">
		</opcode>
		<opcode type="UNU" hex="$EA" string="">
		</opcode>
		<opcode type="UNU" hex="$EB" string="">
		</opcode>
		<opcode type="UNU" hex="$EC" string="">
		</opcode>
		<opcode type="UNU" hex="$ED" string="">
		</opcode>
		<opcode type="IIU" hex="$EE" string="abs_jump">
			<short>Absolute Jump (Undocumented)</short>
			<params>
			</params>
			<stack in_count="0" out_count="1"><![CDATA[ _ => _ , value]]><sparam name="value" class="out"/></stack>
			<description>
				<![CDATA[
Undocumented.
]]>
			</description>
			<tamarincode>
				<![CDATA[
// 'OP_abs_jump' always boils away in the translation to word code, see
			// comments in WordcodeTranslator.cpp.
#ifndef AVMPLUS_WORD_CODE
					
			INSTR(abs_jump)	{
				if (core->interruptCheck(interruptable)) {
					SAVE_EXPC;
					AvmCore::handleInterruptMethodEnv(env);
				}
#  ifdef AVMPLUS_64BIT
				uint32_t target_lo = U30ARG;
				uint32_t target_hi = U30ARG;
				const uint8_t *target = (const uint8_t *)((uint64_t(target_hi) << 32) | uint64_t(target_lo));
#  else // !AVMPLUS_64BIT
				const uint8_t *target = (const uint8_t *) U30ARG;
#  endif // AVMPLUS_64BIT
				codeStart = pc = target;
				NEXT;
            }
					
#endif // !AVMPLUS_WORD_CODE

#if defined(AVMPLUS_WORD_CODE) && !defined(AVMPLUS_DIRECT_THREADED)
			// Fleshes out the dispatch table so that it's 0..255, allows
			// some compilers to generate better code for the switch at the
			// top, which switches on the low 8 bits.  (0 is an illegal
			// opcode; 255 is OP_ext, for which there's a case below.)
			case 0: {
				AvmAssert(false);
			}
#endif

#ifdef AVMPLUS_WORD_CODE
#  ifdef MSVC_X86_REWRITE_THREADING
			default:
				// Keep L_illegal_op and L_push_doublebits alive...
				if ((int)pc > 0x100000)
					goto L_push_doublebits;
				break;
#  endif
]]>
			</tamarincode>
		</opcode>
		<opcode type="IID" hex="$EF" string="debug">
			<short>Debugging info.</short>
			<params>
				<param name="debug_type" type="u8" class="integer"/>
				<param name="index" type="u30" class="string"/>
				<param name="reg" type="u8" class="localregister"/>
				<param name="extra" type="u30" class="integer"/>
			</params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[
debug_type is an unsigned byte. If the value of debug_type is DI_LOCAL (1), then this is
debugging information for a local register.
index is a u30 that must be an index into the string constant pool. The string at index is the
name to use for this register.
reg is an unsigned byte and is the index of the register that this is debugging information for.
extra is a u30 that is currently unused.
When debug_type has a value of 1, this tells the debugger the name to display for the register
specified by reg. If the debugger is not running, then this instruction does nothing.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				WORD_CODE_ONLY( pc += 4 );
				ABC_CODE_ONLY( pc += AvmCore::calculateInstructionWidth(pc-1) - 1 );
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IID" hex="$F0" string="debugline">
			<short>Debugging line number info.</short>
			<params>
				<param name="linenum" type="u30" class="integer"/>
			</params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[
linenum is a u30 that indicates the current line number the debugger should be using for the
code currently executing.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				u1 = U30ARG;
				DEBUGGER_ONLY( if (core->debugger()) core->debugger()->debugLine((int32_t)u1); )
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="IID" hex="$F1" string="debugfile">
			<short>Debugging filename info.</short>
			<params>
				<param name="index" type="u30" class="string"/>
			</params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[
index is a u30 that must be an index into the string constant pool

If the debugger is running, then this instruction sets the current file name in the debugger to
the string at position index of the string constant pool. This lets the debugger know which
instructions are associated with each source file. The debugger will treat all instructions as
occurring in the same file until a new debugfile opcode is encountered.
This instruction must occur before any debugline opcodes.
]]>
			</description>
			<tamarincode>
				<![CDATA[
				SAVE_EXPC;
				u1 = U30ARG;
				DEBUGGER_ONLY( if (core->debugger()) core->debugger()->debugLine((int32_t)u1); )
				NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$F2" string="">
		</opcode>
		<opcode type="IIU" hex="$F3" string="timestamp">
			<short>Timestamp</short>
			<params>
			</params>
			<stack in_count="0" out_count="0"><![CDATA[ _ => _ ]]></stack>
			<description>
				<![CDATA[
Undocumented.
]]>
			</description>
			<tamarincode>
				<![CDATA[
                NEXT;
]]>
			</tamarincode>
		</opcode>
		<opcode type="UNU" hex="$F4" string="">
		</opcode>
		<opcode type="UNU" hex="$F5" string="">
		</opcode>
		<opcode type="UNU" hex="$F6" string="">
		</opcode>
		<opcode type="UNU" hex="$F7" string="">
		</opcode>
		<opcode type="UNU" hex="$F8" string="">
		</opcode>
		<opcode type="UNU" hex="$F9" string="">
		</opcode>
		<opcode type="UNU" hex="$FA" string="">
		</opcode>
		<opcode type="UNU" hex="$FB" string="">
		</opcode>
		<opcode type="UNU" hex="$FC" string="">
		</opcode>
		<opcode type="UNU" hex="$FD" string="">
		</opcode>
		<opcode type="UNU" hex="$FE" string="">
		</opcode>
		<opcode type="UNU" hex="$FF" string="OP_ext">
			<stack in_count="0" out_count="0"></stack></opcode>
	</opcodes>
	<extended>
		<opcode type="UNU" hex="$100">
		</opcode>
		<opcode type="III" hex="$101" string="pushbits">
		</opcode>
		<opcode type="III" hex="$102" string="push_doublebits">
		</opcode>
		<opcode type="IIP" hex="$103" string="get2locals">
		</opcode>
		<opcode type="IIP" hex="$104" string="get3locals">
		</opcode>
		<opcode type="IIP" hex="$105" string="get4locals">
		</opcode>
		<opcode type="IIP" hex="$106" string="get5locals">
		</opcode>
		<opcode type="IIP" hex="$107" string="storelocal">
		</opcode>
		<opcode type="IIP" hex="$108" string="add_ll">
		</opcode>
		<opcode type="IIP" hex="$109" string="add_set_lll">
		</opcode>
		<opcode type="IIP" hex="$10A" string="subtract_ll">
		</opcode>
		<opcode type="IIP" hex="$10B" string="multiply_ll">
		</opcode>
		<opcode type="IIP" hex="$10C" string="divide_ll">
		</opcode>
		<opcode type="IIP" hex="$10D" string="modulo_ll">
		</opcode>
		<opcode type="IIP" hex="$10E" string="bitand_ll">
		</opcode>
		<opcode type="IIP" hex="$10F" string="bitor_ll">
		</opcode>
		<opcode type="IIP" hex="$110" string="bitxor_ll">
		</opcode>
		<opcode type="IIP" hex="$111" string="add_lb">
		</opcode>
		<opcode type="IIP" hex="$112" string="subtract_lb">
		</opcode>
		<opcode type="IIP" hex="$113" string="multiply_lb">
		</opcode>
		<opcode type="IIP" hex="$114" string="divide_lb">
		</opcode>
		<opcode type="IIP" hex="$115" string="bitand_lb">
		</opcode>
		<opcode type="IIP" hex="$116" string="bitor_lb">
		</opcode>
		<opcode type="IIP" hex="$117" string="bitxor_lb">
		</opcode>
		<opcode type="IIP" hex="$118" string="iflt_ll">
		</opcode>
		<opcode type="IIP" hex="$119" string="ifnlt_ll">
		</opcode>
		<opcode type="IIP" hex="$11A" string="ifle_ll">
		</opcode>
		<opcode type="IIP" hex="$11B" string="ifnle_ll">
		</opcode>
		<opcode type="IIP" hex="$11C" string="ifgt_ll">
		</opcode>
		<opcode type="IIP" hex="$11D" string="ifngt_ll">
		</opcode>
		<opcode type="IIP" hex="$11E" string="ifge_ll">
		</opcode>
		<opcode type="IIP" hex="$11F" string="ifnge_ll">
		</opcode>
		<opcode type="IIP" hex="$120" string="ifeq_ll">
		</opcode>
		<opcode type="IIP" hex="$121" string="ifne_ll">
		</opcode>
		<opcode type="IIP" hex="$122" string="ifstricteq_ll">
		</opcode>
		<opcode type="IIP" hex="$123" string="ifstrictne_ll">
		</opcode>
		<opcode type="IIP" hex="$124" string="iflt_lb">
		</opcode>
		<opcode type="IIP" hex="$125" string="ifnlt_lb">
		</opcode>
		<opcode type="IIP" hex="$126" string="ifle_lb">
		</opcode>
		<opcode type="IIP" hex="$127" string="ifnle_lb">
		</opcode>
		<opcode type="IIP" hex="$128" string="ifgt_lb">
		</opcode>
		<opcode type="IIP" hex="$129" string="ifngt_lb">
		</opcode>
		<opcode type="IIP" hex="$12A" string="ifge_lb">
		</opcode>
		<opcode type="IIP" hex="$12B" string="ifnge_lb">
		</opcode>
		<opcode type="IIP" hex="$12C" string="ifeq_lb">
		</opcode>
		<opcode type="IIP" hex="$12D" string="ifne_lb">
		</opcode>
		<opcode type="IIP" hex="$12E" string="ifstricteq_lb">
		</opcode>
		<opcode type="IIP" hex="$12F" string="ifstrictne_lb">
		</opcode>
		<opcode type="IIP" hex="$130" string="swap_pop">
		</opcode>
		<opcode type="III" hex="$131" string="findpropglobal">
		</opcode>
		<opcode type="III" hex="$132" string="findpropglobalstrict">
		</opcode>
		<opcode type="IID" hex="$133" string="debugenter">
		</opcode>
		<opcode type="IID" hex="$134" string="debugexit">
		</opcode>
		<opcode type="III" hex="$135" string="lix8">
		</opcode>
		<opcode type="III" hex="$136" string="lix16">
		</opcode>
	</extended>
</avm>
